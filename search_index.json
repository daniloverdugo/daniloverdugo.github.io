[["index.html", "Ráster con R Capítulo 1 Plataforma R 1.1 Historia y Origen 1.2 Diseño de la Plataforma R 1.3 RStudio 1.4 Características Principales 1.5 Instalación de Plataforma R y RStudio 1.6 Consideraciones Preliminares", " Ráster con R Danilo A. Verdugo Chaura 2022-03-03 Capítulo 1 Plataforma R 1.1 Historia y Origen R es un sistema o una plataforma que surge de un entorno computacional diseñado originalmente para el cálculo estadístico. Nace como un dialecto de S el cual es un lenguaje de programación desarrollado por John Chambers (Figura 1.1) y otros en la antigua Bell Telephone Laboratorios, originalmente miembro de AT &amp; T Corp. S se inicia en 1976 como un programa interno de análisis estadístico. En 1988 el sistema fue reescrito desde FORTRAN a C y empezó a parecerse al sistema que tenemos hoy en día (esto fue en la versión 3 del lenguaje S). Lo importante de destacar es el espíritu original por el cual fue diseñado el sistema: facilitar el análisis de datos, primero para ellos y eventualmente, para otros. Figura 1.1: John Chambers creador de S. John Chambers describe el anhelo al momento de diseñar el lenguaje S con que los usuarios comenzaran en un entorno interactivo, donde no pensaran conscientemente en sí mismos como programadores. Entonces, cuando sus necesidades fuesen más claras y su sofisticación aumentara, deberían ser capaces de transitar gradualmente a la programación, cuando lenguaje y sistema serían más importantes. La clave fue la transición de usuario a desarrollador. Ellos querían construir un lenguaje que fácilmente podría dar servicio a ambos tipos de usuario. Técnicamente, necesitaban construir un lenguaje que fuese adecuado para el análisis de datos interactivo (basada en línea de comandos), así como para la escritura de programas (como los lenguajes tradicionales de programación). Figura 1.2: Ross Ihaka y Robert Gentleman, los creadores de R. En 1991, Ross Ihaka y Robert Gentleman (Figura 1.2) en el Departamento de Estadística de la Universidad de Auckland crean R. Inspirado en la filosofía de S pero como un proyecto totalmente abierto. En 1993, se hace público. La experiencia de Robert y Ross sobre el desarrollo de R está documentada en un interesante artículo de 1996 en el Journal of Computational and Graphical Statistics (Ihaka and Gentleman 1996). Hoy R se ejecuta en casi cualquier sistema operativo o plataforma informática estándar ¡incluso en una playstation 3! Una característica interesante en muchos proyectos de código abierto son las versiones frecuentes. Estos días se produce una liberación anual importante, por lo general en octubre, donde se incorporan nuevas características principales y lanzadas al público. A lo largo del año, se realizarán lanzamientos de corrección de errores en pequeña escala, según sea necesario. Los lanzamientos frecuentes y ciclo de liberación regular indican un permanente y activo desarrollo del software donde se asegura que los errores serán tratados de una manera oportuna. Por supuesto, el árbol principal de código fuente de R se encuentra bajo el control de un pequeño grupo de desarrolladores. Al momento de escribir estas líneas (mayo 2021) nos encontramos en la versión 4.0.5 o Shake and Throw. Es interesante notar el dato anecdótico que los nombres propios con que se han designado desde la primera versión liberada Great Pumpkin (versión 2.14.0, noviembre 2011) o Trick or Treat (versión 2.15.2, octubre 2012) entre muchas otras hacen referencia a un capítulo específico de la serie animada Peanuts (Figura 1.3). Figura 1.3: Serie animada Peanuts (Snoopy) basada en los comics de Charles Schulz. Otra de las ventajas clave que R posee avanzadas capacidades gráficas con calidad de publicación cuya existencia se ha asegurado desde el principio del proyecto mediante el control muy fino en todos los aspectos de la composición gráfica. 1.2 Diseño de la Plataforma R El éxito alcanzado por el proyecto R no tiene nada que ver con las herramientas en sí mismas, sino más bien con lo activa que sea la comunidad de usuarios, hoy miles de ellos en todo el mundo se han unido para realizar contribuciones como también ayudar a otros a usar R para todo tipo de nuevas e insospechadas aplicaciones. El sistema R base o core o núcleo de la plataforma se compone de las herramientas mínimas para su funcionamiento que se encuentra disponible para varios sistemas operativos: Linux, Windows, Mac e incluso su Código Fuente en la denominada Red Exhaustiva de Archivos R (Comprehensive R Archive Network, CRAN. cran.r-project.org, es una red de servidores ftp y web en todo el mundo que almacenan versiones idénticas y actualizadas de código y documentación para R) 1.3 RStudio Aunque R posee un diseño muy avanzado e inteligente a medida que se realizan rutinas para análisis de datos, gráficos, o se generan archivos temporales de esos mismos procesos o se descargan e instalan diversos paquetes de código adicionales se hace muy difícil de mantener y menos aún generar procedimientos claros, organizados y replicables en distintos entornos informáticos, siendo esta última capacidad crítica para la aproximación científica al análisis de datos. RStudio también es una herramienta libre que hace más fácil el trabajo con R, Loo and De Jonge (2012) definen sus principales características como: Editor de texto, explorador de archivos, visualizador de gráficos todo en el mismo entorno. Trabaja directo con una instalación subyacente de R. Organiza el código y mantiene múltiples proyectos. Mantiene mi investigación reproducible. Mantiene los paquetes en la instalación de R. Crea y comparte reportes. Comparte el código y colabora con otros usuarios. RStudio hoy es una aplicación y una fundación dedicada al soporte de sus productos de código abierto1 como al servicio comercial de capacitación y consultoría en temas estadísticos y R. Su fundador J.J. Allaire también inventa el lenguaje de programación web ColdFusion, Windows Live Writer (programa para escribir y publicar blog), FitNow y LoseIt ambas aplicaciones móviles para ejercicio y pérdida de peso entre otros proyectos tecnológicos. 1.4 Características Principales Algunas propiedades que hacen de RStudio el editor ideal para trabajar con R (tomado de Loo and De Jonge (2012)): Integración con la consola R: Escribe comandos directamente en R dentro de RStudio. Ejecución de código: Ejecuta código directo desde el editor. Paréntesis inteligente: Cierre automático de paréntesis, ilumina selección, cierre de comillas automático. Termina de escribir la palabra previamente iluminada de un menú intellisense. Ayuda en línea: Acceso directo a la ayuda de lenguaje y sintaxis. Atajos de teclado: Tareas repetitivas son asociadas a combinación de teclas. Integra Ayuda, Permite navegar y buscar en las páginas de ayuda nativas de R. Explorador de objetos e Historia: Se puede inspeccionar cada objeto creado en la sesión actual de R y su explorador de historia permite recorrer los comandos utilizados desde el actual hasta el primero de la sesión. Navegar por el código: Saltar entre funciones, llamadas y reportes, visor de datos y visualización tipo grilla para explorar el contenido de los objetos en la sesión actual. Menús de Importar datos: Para los tipos más comunes de archivo, ofrece un sistema de menú que genera el código R necesario. Integración gráfica con zoom, paneo y capacidades de exportación. Gestión de proyectos: Facilita el manejo y control de varios proyectos. Control de versión e integra los sistemas de control git y svn. Generación de Documentos: Genera pdf, html y otros formatos de reporte usando RMarkdown, Sweave o knitr. Publicación: Publicar reportes y rutinas directo a la web de Rpubs.com. 1.5 Instalación de Plataforma R y RStudio Primero se debe descargar el paquete de instalación desde el sitio web www.r-project.org siguiendo el link CRAN y buscar en el listado de servidores espejo el más cercano a la ubicación del usuario. Luego, seleccionar la versión correspondiente al sistema operativo de la máquina a instalar. A continuación, prestar atención y ubicar el link install R for the first time en el apartado base. Finalmente, encontramos el link para la descarga del paquete instalador, siempre será le versión más reciente. Ejecutar el programa y seguir los pasos indicados por el asistente.2 Una vez terminada la instalación de R procedemos a instalar el programa RStudio desde el sitio www.rstudio.com y buscar en la lista de productos RStudio Desktop. A continuación, seleccionar la versión Open Source Edition que es libre de pago. Finalmente seguir la secuencia de botones correspondiente hasta llegar al punto de descarga del paquete de instalación. Poner especial atención en seleccionar el que corresponda a su versión de sistema operativo. Ejecutar el programa y seguir los pasos indicados por el asistente. 1.6 Consideraciones Preliminares El entorno de trabajo de RStudio posee una configuración por defecto que presenta una distribución de funcionalidades orientada al uso como entorno interactivo de cálculo y proceso de datos mediante línea de comandos contenido en la ventana Console y una vista general de los objetos y variables creadas en la sesión actual en la ventana Environment (Figura 1.4). Figura 1.4: Configuración por defecto. El tipo de trabajo descrito en el presente texto utiliza metodologías más complejas y extensas que trabajar solo como calculadora o proceso de datos. Por lo tanto, vamos a sugerir una nueva distribución de ventanas que optimicen el trabajo en un tipo de archivos que permiten ir escribiendo largas secuencias de comandos que van desarrollando las tareas de manera secuencial y por seguridad buscamos grabar en disco un archivo que la próxima vez me permita repetir dicha secuencia y continuar o modificar según el caso. Los archivos creados tendrán la extensión .R y los denominaremos scripts. Figura 1.5: Configuración sugerida. Una mejor disposición de ventanas es la sugerida en la figura 1.5. Donde se privilegia el panel izquierdo para extender a altura completa el editor de texto y maximizar el área disponible para escribir y editar scripts y mantiene el panel derecho la consola con su línea de comando. Otro aspecto importante es el uso de un color de fondo obscuro que reduce la fatiga visual cuando se sienta frente al monitor durante períodos muy prolongados. Otra característica configurada por defecto es que al momento de salir de una sesión, es guardar el espacio de trabajo lo que significa que se crea una imagen de las variables y funciones actuales en un archivo llamado .RData. Cuando se vuelve a abrir R desde el mismo directorio de trabajo, el espacio de trabajo se cargará y todas estas cosas estarán disponibles. Pero no recomendamos ese comportamiento. Cargar un espacio de trabajo guardado convierte el script cuidadosamente escrito donde todo sucede lógicamente de acuerdo con un plan a algo parecido a un cajón de sastre, lleno de páginas y cuadernos variados que pueden ser o no pertenecientes al trabajo actual. Para configurar nuestro programa recomendamos cambiar algunos parámetros en la configuración general de la aplicación, para ellos debemos ir a la opción de menú Tools/Global Options. (Figura 1.6). Figura 1.6: Opción de menú para configuración general. El cuadro de dialogo resume un gran número de parámetros que abarcan detalles del funcionamiento general de RStudio (Figura 1.7). Los siguientes cambios son necesarios para configurar los aspectos mencionados en punto anterior: General: Para quitar la carga automática de variables y funciones de la última sesión, debemos en el grupo Workspace quitar el check de Restore .RData into y seleccionar la opción Never de la lista Save workspce to .RData (Figura 1.7). Figura 1.7: Panel de configuración general. Appearance: La configuración de colores en el editor de texto y los otros cuadros se selecciona en la lista Editor theme: y se debe tener especial cuidado en elegir aquel con un fondo negro o muy obscuro (Figura 1.8). Figura 1.8: Selección para configuración de colores. Pane Layout: La distribución de los espacios disponibles para optimizar el editor de texto y mantener la línea de comando visible se configura siguiendo las opciones en indicadas en la figura 1.9). Figura 1.9: Configuración de paneles y cuadros. www.rstudio.com Es importante señalar que el nombre de usuario de la sesión Windows donde se realizará la instalación no existan espacios e idealmente no contenga tildes. De ser así, es recomendable crear una nueva sesión con un nombre sin espacios ni tildes. "],["intro-package.html", "Capítulo 2 Paquetes 2.1 Búsqueda 2.2 Instalación 2.3 Actualización", " Capítulo 2 Paquetes El sistema base, tal como se describe en , es capaz de ejecutar rutinas y código encapsulado en forma de módulos o paquetes (packages) que amplifican y diversifican las posibilidades de cómputo, gráfica, conexiones remotas, generación de documentos y un gran, gran etc. El sistema base o core también se forma de un conjunto de paquetes. Además de las funciones más fundamentales el sistema base incluye los paquetes utils, stats, datasets, graphics, grDevices, grid, methods, tools, parallel, compiler, splines, tcltk, stats4 y algunos paquetes recomendados: boot, class, cluster, codetools, foreign, KernSmooth, lattice, mgcv, nlme, rpart, survival, MASS, spatial, nnet, Matrix. Cuando se descarga una instalación nueva de R desde CRAN, se obtiene todos los paquetes mencionados, que representa un gran porcentaje de la funcionalidad del sistema. 2.1 Búsqueda Además de la gran cantidad de paquetes instalados por defecto, existe una gran cantidad de paquetes opcionales disponibles. A noviembre 2021 existen 18.407 paquetes en CRAN que han sido desarrollados por los usuarios y programadores alrededor del mundo cada uno de ellos diseñado para un campo en especial. También hay muchos paquetes asociados con el proyecto Bioconductor3, (detalles en ). Las personas a menudo hacen sus propios paquetes y los hacen disponibles en sus sitios web personales; en realidad no hay manera confiable de realizar un seguimiento de cuántos paquetes están disponibles de este modo. Hay una serie de paquetes que se desarrollan en los repositorios de GitHub y BitBucket pero no existe ninguna lista fiable de todos estos paquetes. El mejor método para buscar en la web, nuevos paquetes es utilizar el sitio rseek.org (Figura 2.1) usando palabras claves y potenciado por el motor de búsqueda de Google. Figura 2.1: Sitio web de búsqueda de contenido asociado a R, modo Package. Generalmente los resultados siempre serán múltiples y variados. 2.2 Instalación Una vez identificado un paquete que ofrece las funcionalidades deseadas se debe instalar en nuestro ambiente R y dejarlo disponible para cuando se necesite. El entorno RStudio cuenta con un panel específico (Figura 2.2). Figura 2.2: Panel Packages. Que junto al listado de paquetes ya instalados se dispone de opciones para instalar y actualizar () los existentes. 2.2.1 Cuadro Diálogo El botón Install levanta un cuadro de diálogo con las opciones de configuración (Figura 2.3) para instalar paquetes disponibles en CRAN o los paquetes descargados en formato .zip de sitios no oficiales. Figura 2.3: Opciones de Instalación vía RStudio. 2.2.2 Función install.packages() Un segundo método de instalación es utilizar la función R escrita directamente en la consola y reemplazando nombre por el paquete deseado. install.packages(&quot;nombre&quot;) 2.3 Actualización El botón del panel paquetes levanta el cuadro de diálogo diseñado para la selección de los paquetes a actualizar. La lista solo muestra aquellos disponibles de actualización (Figura 2.4). Figura 2.4: Opciones de Instalación vía RStudio. www.bioconductor.org "],["sin-bas.html", "Capítulo 3 Sintaxis Básica de R 3.1 Operaciones Numéricas 3.2 Asignación 3.3 Naturaleza Vectorial", " Capítulo 3 Sintaxis Básica de R 3.1 Operaciones Numéricas De acuerdo con la configuración de ventanas descrita en el punto anterior la ventana Console se encuentra en la esquina superior derecha junto a las ventanas Terminal y Jobs. En ella trabajaremos interactivamente mediante la línea de comando, su uso puede ser comparado con el uso de una calculadora electrónica que siempre está a la espera del ingreso de una instrucción a continuación del símbolo &gt;. La dinámica de uso es ir ingresando el texto que define la operación o instrucción a realizar y finalizar con la tecla Intro: 1 + 2 + 3 Y R responde con la evaluación inmediata de la operación: ## [1] 6 Los espacios en blanco son removidos automáticamente y la orden es evaluada normalmente: 1+2 + 3 ## [1] 6 Cuando la instrucción se extiende por más de una línea, R se encarga de interpretar la estructura y completitud para ser evaluada: 12 + 3 - 5 + 5 ## [1] 15 También puedes usar el símbolo punto y coma (;) para separar secuencias de instrucciones, pero escritas en la misma línea de código. El editor ofrece algunas facilidades al usuario como el historial de órdenes de las instrucciones digitadas en orden reverso para evitar el retipeo de una instrucción muy extensa. Recorrer con las flechas verticales hasta encontrar el texto buscado y solo editar los cambios requeridos. También cuenta con un potente motor de finalización inteligente que permite obtener ayuda a medida que se escribe nombre de funciones o comandos y cuando se trabaja con scripts también nombres de funciones o variables. Por último, para limpiar todo el texto escrito presionar la tecla escape. Se pueden utilizar los símbolos aritméticos tradicionales +, -, *, / y \\(^\\wedge\\).4 Además se encuentran disponibles las funciones log, exp, sin, cos, tan, sqrt entre muchas otras bien conocidas. También existe el valor de pi. 1 + 2 - 3 * 4 / 5**6; sin(0.33); acos(0.253) ; sqrt(4) ## [1] 2.999232 ## [1] 0.324043 ## [1] 1.315016 ## [1] 2 9 %% 4 ## [1] 1 13.5 %/% 2 ## [1] 6 pi ## [1] 3.141593 También se debe tener en cuenta que los números muy grandes o pequeños serán automáticamente convertidos a notación científica. 1/100000000000000000 ## [1] 1e-17 1*100000000000000000 ## [1] 1e+17 En operaciones más complejas se recomienda el uso de () para fijar el orden o precedencia de las operaciones. Se acepta anidar los paréntesis (()). 3 * 5 + 1 ## [1] 16 3 * (5 + 1) ## [1] 18 1 + (3 + (1 + 2) / 3) ## [1] 5 Las operaciones lógicas se realizan utilizando ciertos símbolos o combinaciones de ellos para obtener resultados lógicos: 2 == 3 ## [1] FALSE 2 &lt; 3 ## [1] TRUE Revisa cuadro para una lista completa de los caracteres y su significado en las operaciones lógicas. Otros componentes del lenguaje R son: valor lógico verdadero TRUE y falso FALSE, infinitud positiva Inf y negativa -Inf, no disponible NA, no es un número NaN y nulo o vacío NULL. Finalmente, no podemos intercambiar mayúsculas o minúsculas al momento de escribir los nombres de instrucciones (por ej. sin no es igual a Sin). Y en R todo es un objeto que pertenecen a cierto tipo de clases. Así cada uno de ellos tendrá comportamientos y usos diferentes. class(1) ## [1] &quot;numeric&quot; class(&quot;palabra&quot;) ## [1] &quot;character&quot; class(sqrt) ## [1] &quot;function&quot; class(1 != 1) ## [1] &quot;logical&quot; class(TRUE) ## [1] &quot;logical&quot; class(Sys.Date()) ## [1] &quot;Date&quot; 3.2 Asignación El proceso de almacenar cualquiera de los objetos ya descritos, o el resultado de las operaciones en memoria RAM y hacerlo persistente a lo largo de la sesión actual de trabajo se denomina asignación. Resultados intermedios se deben ir asignado con un nombre fácilmente identificable y memorizables.5 Es conveniente adoptar un estilo de escritura para los nombres de los objetos y para ellos existen varios métodos entre los cuales podemos destacar: lowercase: todominusculas. UPPERCASE: TODOMAYUSCULAS. UpperCamelCase: PrimeraMayusculaSiguientesBajas. lowerCamelCase: primeraMinusculaSiguientesMayusculas. period.separated: separada.por.punto. snake_case: separada_por_guion_bajo. En el sitio web style.tidyverse.org donde se discuten buenas prácticas para el uso de R se recomienda el último tipo. La forma de realizar una asignación tiene la forma general: \\[\\begin{equation} \\label{eq:solve} nombre = valor \\end{equation}\\] Donde \\(nombre\\) es el identificador o nombre del objeto o variable que se busca crear y almacenar en memoria, \\(=\\) el operador de asignación (no confundir con ==) y \\(valor\\) es el contenido a almacenar.6 radio_estimado = 135.45 \\(nombre\\) será sintácticamente válido cuando consta de letras, números o punto y comienza con una letra o el punto, pero no seguido de un número. Los nombres como .2var no son válidos, ni tampoco las palabras reservadas. En la actualidad el uso &lt;- o = es casi indistinto, pero en casos muy específicos (y técnicos) existen diferencias. En nuestro libro recomendamos el uso de &lt;- ya que es un poco más cómodo de tipear que el carácter =. variable &lt;- (112.33 - 45) / 105 Una vez escrita la asignación y presionado intro se realiza la operación, se crea el objeto en memoria con nombre variable y la línea de comando se limpia. Para conocer el resultado de la operación podemos: Figura 3.1: Panel Environment. Buscar el resultado en el panel Environment en la esquina inferior derecha (Figura 3.1). Escribir la asignación dentro de un juego de paréntesis redondos () que obliga imprimir el resultado de la evaluación de la expresión. (variable &lt;- (112.33 - 45) / 105) ## [1] 0.6412381 Volver a escribir el nombre y presionar intro. variable ## [1] 0.6412381 Utilizar el comando print(). print(variable) ## [1] 0.6412381 El principal objetivo de almacenar en memoria es la reutilización de dichos contenidos: radio_inicial &lt;- 15.43 + 36.315 * (3 * 5) (area_base &lt;- pi * radio_inicial ** 2) ## [1] 985748.9 Al asignar un nuevo contenido con el mismo nombre, el anterior se elimina de memoria y se crea un nuevo objeto. x &lt;- 5 x &lt;- &quot;hola&quot; x ## [1] &quot;hola&quot; El comando ls() me permite listar todos los objetos almacenados en mi sesión actual y rm(list = ls()) borrará la totalidad de objetos de mi sesión actual. 3.3 Naturaleza Vectorial En todas las ocasiones que hemos escrito una operación aritmética o impreso un resultado R crea automáticamente un vector7 con una longitud que corresponde a los valores por almacenar. Si estudiamos el ejemplo siguiente: 5 ## [1] 5 ls() ## [1] &quot;area_base&quot; &quot;radio_inicial&quot; &quot;variable&quot; &quot;x&quot; Vemos un [1] antecediendo al número 5 que indica que se trata del primer (y único en este caso) elemento, mientras que en el caso del comando ls() la lista de respuesta por cada renglón que se extienda en la consola antecederá su correspondiente [] señalando la posición en el vector generado automáticamente. 3.3.1 Función c() para crear vectores La creación manual de vectores usando elementos individuales se realiza mediante la función c(). En el siguiente ejemplo hemos incorporado dos nuevos elementos: ; (punto y coma) que nos permite separar dos instrucciones en la misma línea. # (almohadilla o numeral) sirve para crear COMENTARIOS: textos que no serán evaluados por R. c(1, 4, 8, 11) #Sin asignar a nombre de objeto ## [1] 1 4 8 11 x &lt;- c(2, 4, 6, 8); print(x) ## [1] 2 4 6 8 y &lt;- c(x, 100, 101, 102); y ## [1] 2 4 6 8 100 101 102 z &lt;- c(&quot;azul&quot;, &quot;rojo&quot;, &quot;verde&quot;, &quot;amarillo&quot;); (z) ## [1] &quot;azul&quot; &quot;rojo&quot; &quot;verde&quot; &quot;amarillo&quot; 3.3.2 Uso de Secuencias para crear vectores Una secuencia numérica se construye usando el operador :. Por ejemplo: 1:30 Es equivalente a c(1, 2, 3, ... , 30), también es capaz de crear secuencias negativas y/o usar valores decimales. Comprueba las siguientes operaciones y sus resultados: 30 : 1 -10 : -8 1.5 : 5 La prioridad del comando : es máxima y siempre será evaluado al inicio. Compara las secuencias obtenidas entre 1:5-1 y 1:(5-1). 3.3.3 Usar Repetición para la creación de vectores El comando rep() genera un vector con la repetición de un valor un número determinado de veces. También se puede repetir un texto, una fecha o una secuencia definida con la opción :. Revisar usando alguna de las formas de ayuda en línea los argumentos, nombres y usos para el comando rep: rep(1, 5); rep(&#39;a&#39;, 5) ## [1] 1 1 1 1 1 ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; rep(c(1:3, 7), 3); rep(x = 1:2, times = 3, each=3) ## [1] 1 2 3 7 1 2 3 7 1 2 3 7 ## [1] 1 1 1 2 2 2 1 1 1 2 2 2 1 1 1 2 2 2 3.3.4 Uso de Patrones para crear vectores El comando seq() genera patrones regulares. Posee múltiples parámetros o argumentos con nombre para configurar el patrón. Los dos primeros desde (from), hasta (to) tendrían el mismo comportamiento que los parámetros del comando :, un tercero paso (by) define el incremento y posee un valor por defecto de 1 y un cuarto argumento define el número de elementos que debe contener la secuencia (length.out)8. En los ejemplos siguientes vemos el uso del comando usando los argumentos en orden preciso sin utilizar sus nombres: seq(1, 10) #from=2, to=10 ## [1] 1 2 3 4 5 6 7 8 9 10 seq(1, 10, 2) #from=2, to=10, by=2 ## [1] 1 3 5 7 9 También al poseer valores por defecto se puede abreviar su uso: seq(to = 5) ## [1] 1 2 3 4 5 seq(from = 3) ## [1] 1 2 3 Pero la verdadera utilidad de los argumentos con nombres es la libertad en el orden de uso: seq(to = 9, from = 1) ## [1] 1 2 3 4 5 6 7 8 9 seq(by = 1.5, from = 1, to = 9) ## [1] 1.0 2.5 4.0 5.5 7.0 8.5 seq(from = 10, by = -3, length.out= 5) ## [1] 10 7 4 1 -2 seq(by = 3, length.out= 6) ## [1] 1 4 7 10 13 16 La misma lógica se aplica al trabajo con fechas: seq(as.Date(&quot;1910/1/1&quot;), as.Date(&quot;1912/1/1&quot;), &quot;years&quot;) ## [1] &quot;1910-01-01&quot; &quot;1911-01-01&quot; &quot;1912-01-01&quot; seq(from= as.Date(&quot;2000/1/1&quot;), by = &quot;month&quot;, length.out = 3) ## [1] &quot;2000-01-01&quot; &quot;2000-02-01&quot; &quot;2000-03-01&quot; inicio &lt;- as.Date(&quot;1999-12-17&quot;) fin &lt;- as.Date(&quot;2000-3-7&quot;) seq(from= fin, to= inicio, by = &quot;-1 month&quot;) ## [1] &quot;2000-03-07&quot; &quot;2000-02-07&quot; &quot;2000-01-07&quot; 3.3.5 Vectores Lógicos y Caracteres Además de los vectores numéricos y fechas R soporta del tipo lógico y texto. En el caso de vectores lógicos solo puede tomar dos valores: FALSE (falso) y TRUE (verdadero), también son válidos F y T. Generalmente son construidos a partir del uso de los operadores lógicos (ver Cuadro ) en condiciones. Por ejemplo: enteros &lt;- 1:6 (prueba &lt;- enteros &lt;=3) ## [1] TRUE TRUE TRUE FALSE FALSE FALSE Donde prueba almacena un vector de la misma longitud que enteros y cuyo contenido será tanto True o False dependiendo si o no cumplen la condición. También vectores de texto o caracteres pueden ser creados. Los textos o frases deben ser escritos entre comillas (\") o comillas simples (), por ejemplo 'Este texto está entre comillas.'. Generalmente utilizada en la construcción de vectores con c(). rep(x=c(&#39;x&#39;,&#39;y&#39;), times= 4) ## [1] &quot;x&quot; &quot;y&quot; &quot;x&quot; &quot;y&quot; &quot;x&quot; &quot;y&quot; &quot;x&quot; &quot;y&quot; El acento circunflejo \\(^\\wedge\\) se utiliza para la potenciación (se obtiene combinando las teclas alt+94) también se puede reemplazar con \\(**\\). Además, existe la operación módulo (%%) y la división entera (%/%). Los nombres de los objetos deben en lo posible resumir el contenido, evitar nombres genéricos como a u X y no ambiguos como variable o constante. Pueden contener letras, números, puntos y guiones o barra baja (_). Siempre debe comenzar con una letra o punto. En R se ha utilizado tradicionalmente como operador de asignación &lt;- que viene desde la primera versión de R, dado que su origen proviene del lenguaje S y a la vez éste fue inspirado por el lenguaje APL (A Programming Language, Kenneth Iverson en 1957-62) que utilizaba dicho carácter ya que el símbolo = se utilizaba solo para prueba de igualdad. Un Vector es el tipo de objeto más básico del lenguaje R. Un vector puede contener cero o más objetos, y siempre serán de la misma clase. La mayoría de funciones en R poseen parámetros o argumentos con nombre que permiten ajustar el funcionamiento. El orden y sus nombres lo encuentras usando la ayuda en línea. En R el sistema es muy poderoso y fácil de utilizar, basta ubicar el cursor sobre el nombre de comando y presionar F1 y un panel con información detallada con: Descripción: Breve descripción de funcionamiento. Uso: Sintaxis con el orden y nombres de argumentos. Argumentos: Lista detallada y en orden correspondiente de los argumentos. Detalles: Información adicional. Valor: El objeto que retorna. Ejemplos: Código R con alternativas de uso. Será desplegada en el panel inferior derecho. También puedes escribir en la consola el símbolo de interrogación y a continuación el nombre del comando: ?seq o usar el comando help('seq'). "],["op-vec.html", "Capítulo 4 Operación Vectorial 4.1 Operaciones Numéricas 4.2 Valores Faltantes 4.3 Indexado y Subconjunto 4.4 Edición de Contenido 4.5 Opciones Avanzadas", " Capítulo 4 Operación Vectorial 4.1 Operaciones Numéricas Toda operación en R se realiza utilizando los vectores elemento a elemento. Si poseen distinta longitud el resultado tendrá la longitud del mayor y los restantes serán reciclados9. x &lt;- c(100, 800) y &lt;- 2:7 y + x + 3 ## [1] 105 806 107 808 109 810 Donde el vector x se repite tres veces, el número 3 seis veces todo para igualar la longitud del vector y. Algunas funciones se aplican a cada uno de los elementos y otros devuelven un cálculo que se aplica sobre todo el vector (Ver listado de las más comunes en Tabla 4.1): x &lt;- 3:6; x ## [1] 3 4 5 6 x**2 #Elevar al cuadrado ## [1] 9 16 25 36 sum(x) #Suma el contenido ## [1] 18 Tabla 4.1: Funciones más Comunes Función Definición lenght() Largo o número de elementos min() Mínimo max() Máximo range() Rango mean() Promedio median() Mediana sum() Suma prod() Producto var() cuasi-Varianza sd() Desviación Estándar Podemos mencionar que existen comandos que retornan el vector con un nuevo orden, sort(x) que retorna un vector del mismo largo de x ordenados ascendente o descendente vía parámetro decreasing y para revertir el orden de los elementos: rev(X) 4.2 Valores Faltantes Puede ocurrir que no todos los componentes de un vector sean conocidos, para R son valor no disponible o NA. Generalmente una operación que incluya un valor NA dará como resultado un NA. La razón es simple, si no se puede definir o expresar en términos concretos todos los elementos que participan en la operación no se puede conocer o expresar en términos concretos el resultado. x &lt;- c(1, 2, 3, 4, NA, 6) mean(x) ## [1] NA Para resolver el problema, existe el parámetro na.rm=TRUE (remover NA) que precisamente indica que la operación se lleve a cabo e ignore cualquier NA (o NaN10): mean(x, na.rm = TRUE) ## [1] 3.2 La función is.na(x) retorna un vector lógico de longitud similar a X con TRUE si corresponde a NA y FALSE en caso contrario. is.na(x) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE Finalmente, no confundir el término NA con un texto NA: is.na(c(&quot;NA&quot;, NA)) ## [1] FALSE TRUE 4.3 Indexado y Subconjunto R posee varios métodos para acceder a elementos individuales o subconjuntos a través de las operaciones de indexación, la forma de alcanzar el i-ésimo elemento de un vector x es mediante la sintáxis x[i]. 4.3.1 Índice Numérico Positivo El índice i puede ser un valor, una secuencia o un vector de números enteros positivos11 que definen los elementos a retornar: x &lt;- 11:19 x[2] ## [1] 12 x[c(2, 2, 2, 5:9)] ## [1] 12 12 12 15 16 17 18 19 Si el índice es mayor que la longitud del vector retornará NA: x[10] ## [1] NA 4.3.2 Índice Numérico Negativo Si los índices son negativos los valores deben ser excluidos: x[-2] ## [1] 11 13 14 15 16 17 18 19 x[c(-2, -4, -(6:9))] ## [1] 11 13 15 4.3.3 Vector Lógico Debe ser un vector de la misma longitud que el vector a evaluar y contiene valores verdaderos o falsos y serán retornados aquellos que corresponden a valores TRUE12. x &lt;- 1:5 test &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE) x[test] ## [1] 1 2 3 El proceso inverso que devuelve los índices de los elementos que cumplen una condición se realiza con el comando wich(): c(12, 5, 6, 9, 11) wich(x &lt;= 9) [1] 2 3 4 Y las versiones más especializadas which.min() y which.max() que retornan el índice del menor y mayor valor del vector. Una forma de construir un vector lógico es en respuesta a condiciones lógicas donde los elementos que cumplen la condición son devueltos: x[x &lt; 3] ## [1] 1 2 x[x &gt; 4 | x &lt; 3] ## [1] 1 2 5 x[x**2 &gt; 4 &amp; x &lt; 5] ## [1] 3 4 4.4 Edición de Contenido Tal como un vector puede ser indexado para obtener valores determinados, podemos usar los mismos métodos para modificar sus valores: x &lt;- 1:5; x[2] &lt;- 1000 x[c(4, 5)] &lt;- 100 x ## [1] 1 1000 3 100 100 4.5 Opciones Avanzadas Un vector puede recibir información adicional que construye un objeto más completo y que facilita su uso y comprensión de su contenido. 4.5.1 Nombrar los Componentes de un Vector El manejo de un índice numérico puede ser complicado relacionarlo con el contenido, así la función names() permite asociar cada elemento del vector con un nombre propio, en el siguiente ejemplo asignamos una letra mayúscula o minúscula, nombres de mes por ejemplo: x &lt;- 1:5; names(x) &lt;- LETTERS[1:5]; x[c(&#39;B&#39;, &#39;D&#39;)] ## B D ## 2 4 Mediante el uso, por ejemplo, de alguna de las constantes internas: LETTERS: Las 26 letras mayúsculas del alfabeto latino. letters: Las 26 letras minúsculas del alfabeto latino. month.abb: Abreviación tres letras para nombres de los meses del año en inglés. month.name: Nombre completo meses del año en inglés. 4.5.2 Información Adicional R permite incorporar un texto informativo a un vector con el objeto de asociar algún antecedente importante para el mismo u otros usuarios: comment(x) &lt;- &quot;texto adicional aclaratorio.&quot; Para ver el contenido asociado al vector x use : attributes(x) ## $names ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## $comment ## [1] &quot;texto adicional aclaratorio.&quot; Reciclar es repetir un vector de longitud menor tantas veces como sea necesario para alcanzar la longitud del mayor utilizado en la operación. Puede usar una fracción para coincidir la longitud y será informado con un mensaje de alerta. NaN corresponden a otro tipo de valores faltantes, hace referencia a una expresión numérica indefinida como por ej. 0/0 o Inf-Inf. Puede contener índices repetidos. Para invertir la selección (rescatar los elementos de índices falsos) debe aplicar el operador de negación !, x[!test]. "],["fac.html", "Capítulo 5 Factores 5.1 Factores Nominales 5.2 Factores Ordinales", " Capítulo 5 Factores Un dato que adopta un valor desde un conjunto finito de valores se denomina data categórica, por ejemplo, el color de ojos, el estado civil o país de origen. Ellos siempre serán discretos (toman un valor específico). Cuando no implican una relación de orden (color azul no es más importante que color negro, o casado es menos importante que soltero) hablamos de data nominal y cuando si existe una relación de orden de algún tipo (sano es mejor que enfermo, joven es menor que anciano) hablamos de data ordinal, ambas son categóricas, pero se diferencian en su relación de orden y en R ese tipo de datos se denominan factores. Un vector de caracteres puede ser convertido en factores utilizando la función factor(): niveles &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;) (factores &lt;- factor(niveles)) ## [1] A B C B ## Levels: A B C 5.1 Factores Nominales El resultado de la conversión a factor fue: ## [1] A B C B ## Levels: A B C Donde vemos además de la lista de valores ahora sin las \"\" ya que no son textos. Aparece el ítem Levels que señala los niveles o categorías disponibles en el nuevo vector de tipo nominal. El orden con que los presenta es en estricto orden alfabético. Vemos que la clase o categoría base es dos, el método para reordenar nuestros niveles es incorporar el parámetro levels: factores &lt;- factor(niveles, levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) o ejecutar la función: levels(factores) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) Y al explorar su contenido vemos la secuencia de niveles como se buscaba: factores ## [1] A B C B ## Levels: A B C 5.2 Factores Ordinales Hasta ahora tenemos un vector de clases o categorías en la secuencia que deseamos, pero no contiene información relativa a orden o magnitud, por lo tanto no es capaz de ser evaluada por operaciones lógicas: factores &gt; &#39;B&#39; ## Warning in Ops.factor(factores, &quot;B&quot;): &#39;&gt;&#39; not meaningful for factors ## [1] NA NA NA NA Para convertir nuestra data a formato ordinal debemos agregar el parámetro ordered = TRUE que indica a R que existirá un orden definido por los niveles de levels. factores &lt;- factor(niveles,levels= c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), ordered= TRUE) Y así nuestro vector tendrá la capacidad de ser evaluado: factores &lt; &#39;B&#39; ## [1] TRUE FALSE FALSE FALSE factores == &#39;C&#39; ## [1] FALSE FALSE TRUE FALSE "],["mat.html", "Capítulo 6 Matrices 6.1 Operaciones Numéricas 6.2 Indexado y Subconjunto 6.3 Edición de Contenido 6.4 Opciones Avanzadas", " Capítulo 6 Matrices Un vector posee un índice por lo tanto es unidimensional, si agregamos una segunda dimensión se convierte en bidimensional y se denomina matriz. La función en R para construir una matriz es matrix() y requiere dos parámetros de dimensión, además de los datos. La primera dimensión corresponde al número de filas y la segunda dimensión corresponde al número de columnas. matrix(1:8, 2, 4) ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 ## [2,] 2 4 6 8 Aunque se recomienda utilizar los parámetros con nombre por facilidad de uso: matrix(nrow = 5, ncol = 3) ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA ## [3,] NA NA NA ## [4,] NA NA NA ## [5,] NA NA NA matrix(1:15, ncol = 3, nrow = 5) ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 Si necesita convertir un vector x evitando duplicar el objeto a una matriz puede intentarlo así: dim(x) &lt;- c(num_filas, num_columnas) Donde dim es una función que redefine las dimensiones de la matriz. El parámetro byrow cambia la forma de asignar los datos de columna en columna a fila por fila: matrix(1:15, ncol = 3, nrow = 5, byrow = T) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 ## [5,] 13 14 15 6.1 Operaciones Numéricas Las matrices responden a las mismas reglas de operación que los vectores realizando las operaciones elemento a elemento: (mi_matriz &lt;- matrix(1:6,nrow=2, ncol=3)) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 mi_matriz * 2 ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 4 8 12 mi_matriz + 2 / mi_matriz ** 3 ## [,1] [,2] [,3] ## [1,] 3.00 3.074074 5.016000 ## [2,] 2.25 4.031250 6.009259 Y así podemos aplicar las funciones detalladas en : length(mi_matriz) #largo del vector ## [1] 6 min(mi_matriz) #encuetra valor mínimo ## [1] 1 max(mi_matriz) #encuentra valor máximo ## [1] 6 range(mi_matriz) #encuentra el rango ## [1] 1 6 mean(mi_matriz) #promedio ## [1] 3.5 median(mi_matriz) #mdiana ## [1] 3.5 sum(mi_matriz) #sumatoria ## [1] 21 prod(mi_matriz) #producto de todos elementos ## [1] 720 var(mi_matriz) #varianza ## [,1] [,2] [,3] ## [1,] 0.5 0.5 0.5 ## [2,] 0.5 0.5 0.5 ## [3,] 0.5 0.5 0.5 sd(mi_matriz) #desviación estándar ## [1] 1.870829 Y existe una serie de funciones especialmente diseñadas para matrices. dim(mi_matriz) #Dimensión de la matriz, fila x columna ## [1] 2 3 nrow(mi_matriz) #Número de filas ## [1] 2 ncol(mi_matriz) #Número de columnas ## [1] 3 rowSums(mi_matriz, na.rm = T) #Suma elementos por filas ## [1] 9 12 colSums(mi_matriz, na.rm = T) #Suma elementos por columnas ## [1] 3 7 11 rowMeans(mi_matriz) #Promedio por filas ## [1] 3 4 colMeans(mi_matriz) #Promedio por columnas ## [1] 1.5 3.5 5.5 6.2 Indexado y Subconjunto Las mismas reglas aplicadas a los vectores son aplicables a las matrices, considerando sí que el índice i en x[i, ] será la i-ésima fila, el índice j en x[ , j] será la j-ésima columna y x[i, j] refiere al ij-ésimo elemento de x. Los índices i y j deben ser vectores numéricos. (mi_matriz &lt;- matrix(1:6, 3, 2, byrow = T)) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 mi_matriz[2, 1] ## [1] 3 mi_matriz[c(1, 3), 2] ## [1] 2 6 mi_matriz[1, ] ## [1] 1 2 mi_matriz[2:3, ] ## [,1] [,2] ## [1,] 3 4 ## [2,] 5 6 mi_matriz[, 1] ## [1] 1 3 5 mi_matriz[, 1:2] ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 6.3 Edición de Contenido Modificar valores se hace aplicando las mismas técnicas del punto anterior, se selecciona un subconjunto y se asignan los valores: mi_matriz[3, 2] &lt;- 45.66 #modificar un valor mi_matriz[, 1] &lt;- 333 #modificar toda la columna mi_matriz[c(1, 2), ] &lt;- 777 #modificar todas las filas mi_matriz ## [,1] [,2] ## [1,] 777 777.00 ## [2,] 777 777.00 ## [3,] 333 45.66 6.4 Opciones Avanzadas 6.4.1 Nombres de Filas y Columnas Para facilidad de uso también contamos con un método para asignar nombres a filas y columnas y usar esos nombres como índices: rownames(mi_matriz) &lt;- LETTERS[1:3] colnames(mi_matriz) &lt;- c(&quot;uno&quot;, &quot;dos&quot;) mi_matriz ## uno dos ## A 777 777.00 ## B 777 777.00 ## C 333 45.66 mi_matriz[,&#39;uno&#39;] ## A B C ## 777 777 333 mi_matriz[&#39;B&#39;,&#39;uno&#39;] ## [1] 777 También podemos usar las mismas funciones y un índice para cambiar su nombre: rownames(mi_matriz)[3] &lt;- &quot;Letra C&quot; mi_matriz ## uno dos ## A 777 777.00 ## B 777 777.00 ## Letra C 333 45.66 6.4.2 Modificar Tamaño de Matrices Agregar información (cambiando el tamaño de la matriz) se realiza mediante las funciones cbind() y rbind(), la primera agrega a continuación un nueva columna de datos y la segunda filas: datos_columna &lt;- c(100, 200,300) mi_matriz &lt;- cbind(mi_matriz, nombre_col= datos_columna) datos_fila &lt;- c(1000, 2000, 3000) (mi_matriz &lt;- rbind(mi_matriz, nombre_fil= datos_fila)) ## uno dos nombre_col ## A 777 777.00 100 ## B 777 777.00 200 ## Letra C 333 45.66 300 ## nombre_fil 1000 2000.00 3000 6.4.3 Información Adicional Por último, también contamos con la función comment() para asociar información adicional al objeto. comment(mi_matriz) &lt;- &quot;Información Adicional&quot; attributes(mi_matriz) ## $dim ## [1] 4 3 ## ## $dimnames ## $dimnames[[1]] ## [1] &quot;A&quot; &quot;B&quot; &quot;Letra C&quot; &quot;nombre_fil&quot; ## ## $dimnames[[2]] ## [1] &quot;uno&quot; &quot;dos&quot; &quot;nombre_col&quot; ## ## ## $comment ## [1] &quot;Información Adicional&quot; "],["dataframe.html", "Capítulo 7 Dataframes 7.1 Creación 7.2 Operaciones Numéricas 7.3 Indexado y Subconjunto", " Capítulo 7 Dataframes Un vector y una matriz pueden guardar solo datos del mismo tipo. Para resolver esta limitación se ha definido el objeto dataframe. Un dataframe es una lista de variables del mismo número de filas con nombres de fila únicos. Si no se incluyen variables, los nombres de las filas determinan el número de filas. Los nombres de las columnas no deben estar vacíos y los intentos de utilizar nombres vacíos no es admitido. Se permiten nombres de columna duplicados, pero debe usar la opción check.names = FALSE al momento de crearlo. Sin embargo, no todas las operaciones conservarán los nombres de columna duplicados: por ejemplo, un subconjunto tipo matriz forzará que los nombres de columna en el resultado sean únicos. Si se construye un dataframe a partir de varios objetos deben tener el mismo número de filas, aunque factores y textos se reciclarán un número entero de veces si fuese necesario. Si los nombres de fila no se proporcionan al momento de creación, los nombres de fila se toman del primer componente que tenga nombres adecuados, por ejemplo, un vector con nombre o una matriz con nombres de fila o un dataframe. Si se proporcionó como NULL o no se encontró ningún componente adecuado, los nombres de fila son la secuencia entera que comienza en uno (y dichos nombres de fila se consideran automático). 7.1 Creación Un dataframe, es una estructura matricial cuyas columnas pueden ser de diferentes tipos (numérico, lógico, factor y carácter, etc.). Los vectores deben tener la misma longitud: numeros &lt;- c(2, 3, 5) textos &lt;- c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;) logicos &lt;- c(TRUE, FALSE, TRUE) dataframe &lt;- data.frame(numeros, textos, logicos) dataframe ## numeros textos logicos ## 1 2 aa TRUE ## 2 3 bb FALSE ## 3 5 cc TRUE Los nombres de cada columna pueden ser definidos al momento de crear el objeto: dataframe &lt;- data.frame(&quot;numericos&quot;= numeros, &quot;textual&quot;= textos, &quot;bool&quot;= logicos) dataframe ## numericos textual bool ## 1 2 aa TRUE ## 2 3 bb FALSE ## 3 5 cc TRUE También es posible convertir una matriz a dataframe de manera directa: m1 &lt;- matrix(1:12, nrow = 4, ncol = 3) m1 ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 as.data.frame(m1) ## V1 V2 V3 ## 1 1 5 9 ## 2 2 6 10 ## 3 3 7 11 ## 4 4 8 12 Para revisar el detalle y su estructura: str(dataframe) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ numericos: num 2 3 5 ## $ textual : chr &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; ## $ bool : logi TRUE FALSE TRUE 7.2 Operaciones Numéricas Como el objeto dataframe acepta distintos tipos de datos, las operaciones aritméticas deben ser realizadas sobre las columnas numéricas: dataframe$numericos * 2 Aprovechamos de mencionar que un mecanismo de creación de columna y con nombre en la misma operación: dataframe$cuadrado &lt;- dataframe$numericos ** 2 dataframe ## numericos textual bool cuadrado ## 1 2 aa TRUE 4 ## 2 3 bb FALSE 9 ## 3 5 cc TRUE 25 7.3 Indexado y Subconjunto Subconjunto por número de filas: dataframe[2:3, ] ## numericos textual bool cuadrado ## 2 3 bb FALSE 9 ## 3 5 cc TRUE 25 Subconjunto por nombre de columnas: dataframe[ , c(&quot;bool&quot;,&quot;textual&quot;)] ## bool textual ## 1 TRUE aa ## 2 FALSE bb ## 3 TRUE cc Subconjunto por número de fila y nombre de columnas: dataframe[c(1,2), c(&quot;bool&quot;,&quot;cuadrado&quot;)] ## bool cuadrado ## 1 TRUE 4 ## 2 FALSE 9 7.3.1 Opciones Avanzadas También podemos usar condiciones lógicas para crear subconjuntos: dataframe[dataframe$bool==TRUE,] ## numericos textual bool cuadrado ## 1 2 aa TRUE 4 ## 3 5 cc TRUE 25 dataframe[dataframe$bool==TRUE &amp; dataframe$numericos &lt;5, ] ## numericos textual bool cuadrado ## 1 2 aa TRUE 4 La función subset() provee un formato más económico para realizar subconjuntos: subset(dataframe, bool == T &amp; numericos &lt; 5) ## numericos textual bool cuadrado ## 1 2 aa TRUE 4 7.3.2 Modificar Tamaño o Estructura Las formas de consultar el tamaño y geometría de un objeto: dim(dataframe) ## [1] 3 4 nrow(dataframe) ## [1] 3 ncol(dataframe) ## [1] 4 Podemos agregar una columna siempre y cuando contenga el mismo número de filas: vector &lt;- c(&quot;uno&quot;,&quot;dos&quot;,&quot;tres&quot;) dataframe &lt;- cbind(dataframe, &quot;adicional&quot;= vector) str(dataframe) ## &#39;data.frame&#39;: 3 obs. of 5 variables: ## $ numericos: num 2 3 5 ## $ textual : chr &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; ## $ bool : logi TRUE FALSE TRUE ## $ cuadrado : num 4 9 25 ## $ adicional: chr &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; Y el correspondiente comando para agregar filas: vector &lt;- c(7,&quot;dd&quot;, NA, 0,&quot;cuatro&quot;) str(rbind(dataframe,vector)) ## &#39;data.frame&#39;: 4 obs. of 5 variables: ## $ numericos: chr &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;7&quot; ## $ textual : chr &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot; ## $ bool : chr &quot;TRUE&quot; &quot;FALSE&quot; &quot;TRUE&quot; NA ## $ cuadrado : chr &quot;4&quot; &quot;9&quot; &quot;25&quot; &quot;0&quot; ## $ adicional: chr &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; &quot;cuatro&quot; Si estudiamos con cuidado el resultado, notaremos que la columna numéricos aparece como carácter eso se produce si intentamos agregar una fila usando rbind() y c(), ya que convierte todas las columnas en una clase de carácter. Esto se debe a que todos los elementos del vector creado por c() deben ser de la misma clase, por lo que todos son forzados a la clase de caracteres que obliga a todas las variables en el marco de datos a la clase de caracteres. Para agregar filas de manera adecuada, necesitamos convertir los elementos que se agregan a un dataframe y asegurarnos de que las columnas sean de la misma clase que el dataframe destino. agregar_fila &lt;- data.frame(numericos= 9, textual= &quot;RR&quot;, bool= FALSE, cuadrado= 110, adicional= &quot;cuatro&quot;) (dataframe &lt;- rbind(dataframe, agregar_fila)) ## numericos textual bool cuadrado adicional ## 1 2 aa TRUE 4 uno ## 2 3 bb FALSE 9 dos ## 3 5 cc TRUE 25 tres ## 4 9 RR FALSE 110 cuatro 7.3.3 Nombres de Filas y Columnas rownames(dataframe) &lt;- c(&quot;fila1&quot;, &quot;fila2&quot;, &quot;fila3&quot;, &quot;fila4&quot;) dataframe ## numericos textual bool cuadrado adicional ## fila1 2 aa TRUE 4 uno ## fila2 3 bb FALSE 9 dos ## fila3 5 cc TRUE 25 tres ## fila4 9 RR FALSE 110 cuatro colnames(dataframe) &lt;- c(&quot;col_1&quot;, &quot;col_2&quot;, &quot;col_3&quot;) dataframe ## col_1 col_2 col_3 NA NA ## fila1 2 aa TRUE 4 uno ## fila2 3 bb FALSE 9 dos ## fila3 5 cc TRUE 25 tres ## fila4 9 RR FALSE 110 cuatro 7.3.4 Información Adicional comment(dataframe) &lt;- &quot;Texto informativo adicional&quot; attributes(dataframe) ## $names ## [1] &quot;col_1&quot; &quot;col_2&quot; &quot;col_3&quot; NA NA ## ## $row.names ## [1] &quot;fila1&quot; &quot;fila2&quot; &quot;fila3&quot; &quot;fila4&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $comment ## [1] &quot;Texto informativo adicional&quot; "],["array.html", "Capítulo 8 Array 8.1 Operaciones Numéricas 8.2 Indexado y Subconjunto 8.3 Edición de Contenido 8.4 Opciones Avanzadas", " Capítulo 8 Array Un vector posee un índice por lo tanto es unidimensional, una matriz posee dos dimensiones y es bidimensional y para objetos de una dimensión superior R provee la función array(). Siempre todos los datos deben ser del mismo tipo. Esta nueva dimensión la llamaremos capas, niveles o layers indistintamente en este libro. (y &lt;- array(data = 1:3**3, dim = c(3, 3, 3))) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 8.1 Operaciones Numéricas Un array responde a las mismas reglas de operación que los vectores o matrices realizando las operaciones elemento a elemento: y/3 + y**3 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1.333333 65.33333 345.3333 ## [2,] 8.666667 126.66667 514.6667 ## [3,] 28.000000 218.00000 732.0000 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1003.333 2201.333 4101.333 ## [2,] 1334.667 2748.667 4918.667 ## [3,] 1732.000 3380.000 5838.000 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 6865.333 10655.33 15633.33 ## [2,] 8006.667 12174.67 17584.67 ## [3,] 9268.000 13832.00 19692.00 Y así podemos aplicar las funciones detalladas en : length(y); min(y); max(y); range(y) ## [1] 27 ## [1] 1 ## [1] 27 ## [1] 1 27 mean(y); median(y); sum(y); prod(y) ## [1] 14 ## [1] 14 ## [1] 378 ## [1] 1.088887e+28 var(y); sd(y) ## [1] 63 ## [1] 7.937254 8.2 Indexado y Subconjunto Si en las matrices, el índice i en x[i,,] será la i-ésima fila, el índice j en x[,j,] será la j-ésima columna el índice k en x[,,k] corresponde al k-ésimo nivel, así x[i,j,k] refiere al ijk-ésimo elemento de x. Los índices i, j, k deben ser vectores numéricos. mean(y[, , 1]) #Promedio de nivel 1 ## [1] 5 mean(y[, , 2:3]) #Promedio de niveles 2 y 3 ## [1] 18.5 mean(y[, , c(1,3)]) #Promedio de nivel 1 y 3 ## [1] 14 mean(y[1, ,]) #Promedio de la primera fila (todos los niveles) ## [1] 13 8.3 Edición de Contenido Modificar valores se hace aplicando las mismas técnicas del punto anterior, se selecciona un subconjunto y se asignan los valores: y[1, 2, 2] &lt;- 45.66 #modificar un valor y[,,1] &lt;- 0 #modificar todo el nivel y ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 45.66 16 ## [2,] 11 14.00 17 ## [3,] 12 15.00 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 8.4 Opciones Avanzadas 8.4.1 Nombres de Filas y Columnas Para facilidad de uso también contamos el método dimnames() para asignar nombres por dimensión: dimnames(y)[[1]] &lt;- LETTERS[1:3] #Nombre de Filas dimnames(y)[[2]] &lt;- LETTERS[12:14] #Nombre de Columnas dimnames(y)[[3]] &lt;- c(&quot;UNO&quot;, &quot;DOS&quot;, &quot;TRES&quot;) #Nombre de Niveles y ## , , UNO ## ## L M N ## A 0 0 0 ## B 0 0 0 ## C 0 0 0 ## ## , , DOS ## ## L M N ## A 10 45.66 16 ## B 11 14.00 17 ## C 12 15.00 18 ## ## , , TRES ## ## L M N ## A 19 22 25 ## B 20 23 26 ## C 21 24 27 y[,&#39;M&#39;,&#39;DOS&#39;] ## A B C ## 45.66 14.00 15.00 8.4.2 Información Adicional Por último, también contamos con la función comment() para asociar información adicional al objeto. comment(y) &lt;- &quot;Información Adicional&quot; attributes(y) ## $dim ## [1] 3 3 3 ## ## $dimnames ## $dimnames[[1]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## $dimnames[[2]] ## [1] &quot;L&quot; &quot;M&quot; &quot;N&quot; ## ## $dimnames[[3]] ## [1] &quot;UNO&quot; &quot;DOS&quot; &quot;TRES&quot; ## ## ## $comment ## [1] &quot;Información Adicional&quot; "],["r-fechas.html", "Capítulo 9 Fechas 9.1 Operaciones con Fecha", " Capítulo 9 Fechas Una fecha denota un día en particular, que denota un período de tiempo que tiene un comienzo y un final diferente. Aunque sus demarcaciones exactas y su duración pueden ser controvertidas, normalmente pensamos en una fecha como un período de 24 horas en un lugar en particular. La instrucción Sys.Date() se utiliza para obtener la fecha actual. Y pertenece a una clase particular Date, que define un objeto que posee una serie de propiedades específicas que vamos a revisar a continuación. 9.1 Operaciones con Fecha Las fechas son almacenadas internamente como el número de días transcurridos a partir del 1 de enero de 1970. Un objeto tipo date es convertido a número con as.numeric(). Para reconocer un texto como objeto fecha debe ser entendido por el sistema y debido a la diversidad de formatos utilizados existe una manera de explicar al sistema cual es el que se utiliza o deseamos utilizar (Tabla 9.1). Tabla 9.1: Caracteres para Formatear Fechas Símbolo Definición %d Día %m Mes Numérico %b Mes 3 letras %B Mes Nombre %y Año Dos Dígitos %Y Año 4 Dígitos 9.1.1 Formato de Fechas En el siguiente ejemplo vamos a convertir varios textos a objeto fecha. as.Date(&#39;07/ene/23&#39;,format= &#39;%d/%b/%y&#39;) ## [1] &quot;2023-01-07&quot; as.Date(&#39;07/enero/2023&#39;,format= &#39;%d/%B/%Y&#39;) ## [1] &quot;2023-01-07&quot; as.Date(&#39;enero-07-2023&#39;,format= &#39;%B-%d-%Y&#39;) ## [1] &quot;2023-01-07&quot; Puede ocurrir que las fechas a procesar no estén en el lenguaje de la máquina y no puede reconocer nombres o abreviaturas. as.Date(&#39;07/jan/23&#39;,format= &#39;%d/%b/%y&#39;) ## [1] NA as.Date(&#39;07/january/23&#39;,format= &#39;%d/%B/%y&#39;) ## [1] NA Para ello R soluciona el problema aplicando una configuración local mediante el comando Sys.setlocale(). Sys.setlocale(&quot;LC_TIME&quot;, locale = &quot;C&quot;) ## [1] &quot;C&quot; as.Date(&#39;07/jan/23&#39;,format= &#39;%d/%b/%y&#39;) ## [1] &quot;2023-01-07&quot; as.Date(&#39;07/january/23&#39;,format= &#39;%d/%B/%y&#39;) ## [1] &quot;2023-01-07&quot; Y para cambiar de regreso a español: Sys.setlocale(&quot;LC_TIME&quot;, locale = &quot;Spanish&quot;) ## [1] &quot;Spanish_Spain.1252&quot; as.Date(&#39;07/ene/23&#39;,format= &#39;%d/%b/%y&#39;) ## [1] &quot;2023-01-07&quot; as.Date(&#39;07/enero/23&#39;,format= &#39;%d/%B/%y&#39;) ## [1] &quot;2023-01-07&quot; Para la extracción de los componentes de una fecha, se pueden utilizar los comandos weekdays, months, days, quarters. weekdays(as.Date(&#39;07/ene/23&#39;,format= &#39;%d/%b/%y&#39;)) ## [1] &quot;sábado&quot; Y como la mayoría de los demás objetos se pueden aplicar operaciones aritméticas. as.Date(x = &quot;13/Abril/2021&quot;, format = &quot;%d/%B/%Y&quot;) - as.Date(x = &quot;07/Ago/20&quot;, format = &quot;%d/%b/%y&quot;) ## Time difference of 249 days fechas &lt;- c(as.Date(x = &quot;13/Abril/2021&quot;, format = &quot;%d/%B/%Y&quot;), as.Date(x = &quot;07/Ago/20&quot;, format = &quot;%d/%b/%y&quot;), as.Date(x = &quot;23/Dic/19&quot;, format = &quot;%d/%b/%y&quot;)) mean(fechas) ## [1] &quot;2020-08-14&quot; min(fechas) ## [1] &quot;2019-12-23&quot; max(fechas) ## [1] &quot;2021-04-13&quot; 9.1.2 Cambio de Formato Si desea usar fechas en un formato distinto al que ya posee o tiene definido, puede hacerlo usando la función format() del paquete base. La fecha actual como se encuentra definida por el sistema: (fecha &lt;- Sys.Date()) ## [1] &quot;2022-03-03&quot; La puedo expresar utilizando los caracteres de formato definidos en el cuadro : format(fecha, &quot;%d %B %Y&quot;) ## [1] &quot;03 marzo 2022&quot; "],["r-hora.html", "Capítulo 10 Hora 10.1 Formato POSIX 10.2 Operando con el tiempo 10.3 Conversión entre zonas horarias", " Capítulo 10 Hora El tiempo denota un instante o momento particular dentro de un período de tiempo más largo. Por lo tanto, el tiempo se suele considerar como un punto dentro de un día. Mientras que un día típico dura 24 horas, un punto en el tiempo no tiene duración (es decir, su comienzo y final son idénticos). La medición y los informes de tiempos inevitablemente plantean muchos problemas sobre convenciones (AM o PM), su precisión (Minutos, segundos o milisegundos) y ubicación (Husos o zonas horarias). Para especificar con precisión una hora en particular también se requiere especificar la fecha dentro de la cual está incrustado. Por tanto, nuestras definiciones de objetos de tiempo serán necesariamente más complejas que las de objetos de fecha. El paquete base, responde a la pregunta de San Agustín ¿Qué es entonces el tiempo? con no menos de tres clases de objetos para representar fechas y horas: Date: representa la fecha de los días sin considerar los tiempos (revisada en el punto anterior). POSIXct: la principal clase de fecha y hora para representar la hora del calendario. POSIXlt: una clase adicional de fecha y hora para representar la hora local (como listas). POSIXct es más conveniente para incluir en objetos de datos como un dataframe, y POSIXlt está más cerca de los formularios legibles por humanos. Existe una clase virtual POSIXt de la que heredan ambas clases: se utiliza para permitir operaciones como la resta para mezclar ambas clases. La hora actual se obtiene con la función: Sys.time() ## [1] &quot;2022-03-03 17:05:20 -03&quot; Que retorna un objeto POSIXct que se compone de una fecha y una hora en una zona horaria determinada. ahora &lt;- Sys.time() class(ahora) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; El tiempo se cuenta desde 1970-01-01 00:00:00 UTC (una fecha arbitraria). Para conocer la zona horaria existe la función13: Sys.timezone() ## [1] &quot;America/Santiago&quot; 10.1 Formato POSIX El acrónimo POSIX significa Interfaz de sistema operativo portátil y define estándares para mantener la compatibilidad entre diferentes sistemas operativos de computadora (con la X implicando Unix, debido a su independencia de un fabricante en particular). Define un estándar para expresar y acordar especificaciones de conversión. En el código, se usa dentro de una cadena de caracteres y se introduce con el símbolo %, generalmente seguido de una sola letra (Tabla 10.1). Tabla 10.1: Caracteres para Formatear el tiempo Símbolo Definición %H Hora dos dígitos (0-23) %I Hora dos dígitos (0-12) %M Minutos dos dígitos (0-59) %p Indicador AM/PM %S Segundos dos dígitos (0-59) %Z Zona horaria o desplazamiento UTC Estos símbolos existen y comparten con los símbolos de fechas14: format(ahora, &quot;%A %I:%M&quot;) ## [1] &quot;jueves 05:05&quot; format(ahora, &quot;%H:%M:%S (%Z)&quot;) ## [1] &quot;17:05:20 (-03)&quot; format(ahora, &quot;%H:%M:%S&quot;) ## [1] &quot;17:05:20&quot; 10.2 Operando con el tiempo El objeto tiempo también es capaz de realizar operaciones algebraicas. ahora ## [1] &quot;2022-03-03 17:05:20 -03&quot; Sumar 30 segundos: (despues_s &lt;- ahora + 30) ## [1] &quot;2022-03-03 17:05:50 -03&quot; Sumar 30 minutos: (despues_m &lt;- ahora + (30 * 60)) ## [1] &quot;2022-03-03 17:35:20 -03&quot; Sumar 30 horas (notese el ajuste de la fecha): (despues_h &lt;- ahora + (30 * 60 * 60)) ## [1] &quot;2022-03-04 23:05:20 -03&quot; despues_h - ahora ## Time difference of 1.25 days La función difftime() soporta las siguientes unidades auto, secs, mins, hours, days y weeks. difftime(despues_h, ahora, units = &quot;weeks&quot;) ## Time difference of 0.1785714 weeks Una función útil que también trabaja con tiempos es trunc(). Toma un argumento x, permite especificar el tiempo units de interés y trunca los enteros de cualquier unidad más pequeña a cero: trunc(ahora, units= &quot;mins&quot;) ## [1] &quot;2022-03-03 17:05:00 -03&quot; trunc(ahora, units= &quot;months&quot;) ## [1] &quot;2022-03-01 -03&quot; trunc(ahora, units= &quot;years&quot;) ## [1] &quot;2022-01-01 -03&quot; 10.3 Conversión entre zonas horarias En general, hemos visto que la base R proporciona un amplio soporte para crear y computar con fechas y horas. Al mismo tiempo, tratar con tres clases diferentes y sus relaciones con otros tipos de datos (específicamente: números) es un desafío. Aunque la mayoría de las complicaciones provienen de las complejidades inherentes de fechas y horas, las clases y los comandos R básicos para fechas y horas se han ido desarrollando con el tiempo y se vuelven cada vez más poderosos. Convertir entre zonas horarias, una operación muy compleja se realiza de manera muy práctica. Por ejemplo, deseo conocer la hora de término de un viaje de 15 horas en una zona horaria diametralmente opuesta (note que usamos la versión de hora local lt), entonces, ¿qué hora sería en 15 horas más en Shangái? as.POSIXlt(Sys.time() + (15 * 60 * 60), tz = &quot;Asia/Shanghai&quot;) ## [1] &quot;2022-03-04 19:05:20 CST&quot; Para conocer la lista zonas horarias por su nombre usar OlsonNames(). Para revisar la extensa lista de códigos escribe en la consola ?strftime. "],["EO-intro.html", "Capítulo 11 Observación de la Tierra 11.1 Introducción 11.2 Energía Electromagnética 11.3 La Relación Electricidad Magnetismo 11.4 Cómo se Produce y Transporta la Energía 11.5 El Espectro Electromagnético 11.6 Conceptos Básicos y sus Unidades 11.7 Radiación de Cuerpo Negro", " Capítulo 11 Observación de la Tierra 11.1 Introducción En la actualidad a tomado relevancia el concepto de Observación de la Tierra desde el espacio (EO del inglés) que hace referencia a las actividades de captura de datos de la superficie terrestre a partir de vehículos espaciales diseñados específicamente para observar en un amplio espectro de la energía radiante de la tierra. También al realizar la observación desde lejos (sin contacto con el objeto de estudio) se denominan ya desde principios de la década del 60 como técnicas de teledetección. Las actividades de EO o teledetección incluyen una amplia gama de técnicas para la adquisición, almacenamiento y transmisión de los datos los cuales luego deben ser convertidos en información relevante, que finalmente debe llegar de manera oportuna a una amplia variedad de usuarios finales potencial para el uso de agricultores, como pescadores, periodistas, glaciólogos, ecologistas, geógrafos y un amplio etcétera. De las diversas fuentes de datos hoy las imágenes de satélite de resolución media (el nivel de detalle observable) y de acceso libre (gratis en realidad) se han vuelto ampliamente accesibles, proporcionan cobertura mundial con una amplia variación espectral (región del espectro que pueden sensar) y temporal (período de tiempo entre las observaciones para el mismo punto geográfico), lo que les hace aptos para una amplia gama de estudios. La señal de energía radiante que es detectada y medida por el sensor satelital es almacenada en la memoria a bordo del satélite o transmitida a un receptor en tierra para su posterior interpretación. La teledetección y la EO también incluyen el análisis y la interpretación de los datos adquiridos. La extracción de información relevante requiere de una buena comprensión de la base física, el proceso de adquisición y un conocimiento sólido de los algoritmos utilizados para procesar los datos originales. 11.2 Energía Electromagnética La observación remota requiere algún tipo de interacción energética entre el objetivo y el sensor. La señal detectada por el sensor puede ser energía solar (generada en el Sol) que es reflejada por la superficie de la Tierra, como también puede ser energía emitida desde la superficie por sí misma o la generada por el mismo sensor que produce su propio pulso de energía. Todo este proceso tiene una fuerte base física, ya que implica recopilar señales electromagnéticas (EM) provenientes de objetos con diferentes propiedades físicas y químicas. Y necesariamente debemos comenzar con una descripción básica e histórica de la física que soporta todo este desarrollo. 11.2.1 Fundamentos Históricos y Físicos Todo comienza con dos fenómenos muy simples y observables en la vida diaria, uno el típico chispazo que sentimos en la punta de los dedos luego de caminar sobre una alfombra, o cuando se erizan los cabellos cuando se roza con un trozo de tela o los rayos que observamos en una tormenta, todos ellos productos de la electricidad y dos, el efecto que hace funcionar los imanes o una brújula, el magnetismo. Figura 11.1: Muestra de Ámbar. (foto: De Hannes Grobe-Trabajo propio, CC BY-SA 2.5) 11.2.2 Fenómeno Eléctrico Ya en la antigua Grecia Tales de Mileto notó que al frotar una piedra de ámbar (Figura 11.1) era capaz de atraer por el aire pequeños objetos (ámbar en griego es élektron y de allí deriva la palabra electricidad) y trató de buscar una explicación, aunque para encontrar una verdaderamente moderna del fenómeno de la electricidad, hubo que esperar unos dos mil años por el descubrimiento del electrón, gracias a los trabajos de Sir J.J. Thompson (Figura 11.2). Figura 11.2: Físico Inglés Sir J.J.Thomson. El electrón es una partícula muy ligera y con gran movilidad que existe dentro de los átomos, una partícula que como responde a los efectos eléctricos se dice que está cargada eléctricamente; de hecho, hoy entendemos la electricidad como un movimiento de electrones en un conductor y esta es la base por ejemplo de toda la electrónica moderna y como electrones hay en todas partes es muy fácil generar fenómenos eléctricos. 11.2.3 Fenómeno Magnético También desde la antigüedad (otra vez los griegos y otra vez Tales de Mileto) constatan una extraña fuerza que entre ciertas piedras muy comunes en la Región de Magnesia y ahí su nombre: magnetismo (Figura 11.3). Figura 11.3: Los Propileos de Magnesia del Meandro.Turquía. (foto: De Vadimph-Trabajo propio,CC BY-SA 3.0) La explicación moderna a este magnetismo natural se explica también por los electrones que componen la materia. Hay que imaginar los electrones como pequeños imanes dentro de los materiales normales (aunque por ejemplo en la madera estos pequeños imanes están todos desorientados de forma tal que el efecto general difiere a lo que ocurre en esas piedras especiales). Estos pequeños imanes en los materiales magnéticos están ordenados según una orientación específica, lo que genera un efecto global, lo que genera un gran imán, caracterizado como ya saben por el polo norte y el polo sur, hoy a estos pequeños imanes en los electrones lo conocemos con el nombre de spin, una propiedad cuántica muy peculiar. Los imanes hoy en día los encuentras por todas partes y son una pieza fundamental del desarrollo moderno. Figura 11.4: Daguerrotipo de Hans Christian Ørsted. 11.3 La Relación Electricidad Magnetismo Si ambos fenómenos se relacionan íntimamente con los electrones alguna conexión entre el magnetismo y la electricidad debía existir. La primera indicación de que eran fenómenos realmente conectados la observó Hans Christian Ørsted (Figura 11.4) un físico danés en el siglo 19. Todo fue a raíz de una observación muy importante pero que ocurrió de manera casual, durante una demostración en clases al conectar la corriente en un circuito eléctrico observó que la aguja de una brújula cercana se desviaba y tras numerosas pruebas y experimentos llegó esencialmente a la conclusión correcta: el flujo de cargas -una corriente eléctrica- genera un fenómeno magnético alrededor del cable y esto da lugar a un nuevo tipo de imanes, el electroimán. Si haces pasar una corriente eléctrica por un cable circular (una espira) se crea un campo magnético como el de un imán con un polo norte y un polo sur. Este mecanismo es fundamental en la sociedad moderna dando lugar a los motores eléctricos: la transformación de electricidad en movimiento. Figura 11.5: Grabado de André-Marie Ampère por Ambrose Tardieu. Ørsted publica sus resultados y un joven científico francés muy talentoso, André-Marie Ampère (Figura 11.5) decide probar por su cuenta, dando con lo que se conoce como la ley de Ampère, relativa a las fuerzas de dos cables que conducen corriente. Michael Faraday (Figura 11.6) un joven inglés sin ninguna formación científica oye de estos nuevos desarrollos y se pregunta si una corriente eléctrica es capaz de producir magnetismo ¿el magnetismo será capaz también de crear una corriente eléctrica? una intuición maravillosa y muy científica, luego de un arduo trabajo consiguió probarlo, no sin antes romperse la cabeza ya que esta intuición venía con una pequeña sutileza, no es la presencia del imán en el conductor lo que consigue generar una corriente sino su movimiento. Figura 11.6: Retrato de Michael Faraday pintado por H.W. Pickersgill. Es la variación del magnetismo lo que crea la electricidad, aunque la gran revolución estaba aún por llegar, en todo esto, había algo que no le encajaba al joven Faraday, unas fuerzas misteriosas la eléctrica y magnética se desplazaban por el aire sin ningún tipo de sustento, esto parecía poco físico para él y varios experimentos le hicieron apuntar en la dirección correcta: primero consiguió en un cristal ver una conexión entre la electricidad y la luz y luego tenía el famoso experimento de las limaduras de hierro que espolvoreadas en un papel y pones debajo un imán ves que se generaban patrones que recorrían la distancia entre los polos, para Faraday tenía que existir agua invisible en el aire algo que no podemos ver pero que de alguna forma estaba guiando las limaduras (Figura 11.7) tomada de Black (1913). Figura 11.7: Las limaduras de hierro permiten mostrar la dirección del campo magnético de un imán permanente. Faraday llamó a este peculiar fenómeno campo, este concepto resultó ser uno de los conceptos más poderosos de la historia de la ciencia: un objeto altera las propiedades de su entorno cuando otro cuerpo se acerca a este, es el propio espacio el que ejerce la acción sobre el cuerpo es una forma de transmitir una fuerza por el espacio, una forma que usaría el mismo Albert Einstein en su teoría de la gravedad en la relatividad general. 11.3.1 El Concepto de Campo El concepto de campo fue una de las ideas más importantes de la ciencia, hoy en día todas las modernas teorías de fuerzas e interacciones están basadas en el concepto de campo, la fuerza eléctrica y magnética se transmiten por medio de campos. Con esta revolución se está creando una nueva área de la ciencia y el puntapié inicial la da un joven escocés James Clerk Maxwell (Figura 11.8). Maxwell era un científico sobresaliente de gran intuición y una formación matemática muy sólida y ve en el concepto de campo una herramienta fundamental para llevar al próximo nivel la idea de electricidad y magnetismo apoyado en esta sorprendente simetría. Figura 11.8: Grabado de James Clerk Maxwell por G. J. Stodart. Con la ayuda de los desarrollos teóricos previos junto con el concepto de campo Maxwell desarrolla un todo unificado. Inicialmente 20 ecuaciones que hoy reducidas a cuatro son las famosas ecuaciones de Maxwell uno de los desarrollos más prodigiosos, potentes y revolucionarios que han surgido nunca del intelecto humano. 11.3.2 El Electromagnetismo Cuando Maxwell se propuso resolver sus ecuaciones observó algo muy peculiar: la solución de sus ecuaciones eran una onda. Una onda de electricidad y magnetismo, una onda electromagnética, una onda que se auto sustentaba en el espacio. Una de las propiedades de esta onda es que la velocidad a la que se desplaza es exactamente la velocidad de la luz. Ese descubrimiento le lleva a teorizar: Esta velocidad es tan próxima a la de la luz, que parece que tenemos sólidas razones para concluir que la propia luz (incluyendo el calor radiante, y otras radiaciones si las hay) es una perturbación electromagnética en forma de ondas que se propagan de acuerdo con las leyes del electromagnetismo. Como hemos descubierto hasta ahora, si la variación del campo magnético es el que genera el campo eléctrico y viceversa, podemos pensar en el caso de la luz, tomamos un electrón en el vacío que de repente oscila, esto hace que se genere el magnetismo -un campo magnético- que tiene la propiedad de penetrar el vacío, luego, ese campo magnético va decreciendo y esta variación a su vez genera un campo eléctrico que se va haciendo cada vez más grande según el campo magnético va disminuyendo y en ese momento ocurre lo contrario, el campo eléctrico empieza a disminuir lo que va generando un campo magnético y así sucesivamente. Ambos de forma acoplada se van reformando y reforzando, permitiendo que la perturbación viaje hasta el infinito. Así el campo eléctrico y el campo magnético en una onda electromagnética vibran perpendicularmente (90°) entre sí (Figura 11.9). Figura 11.9: Onda electromagnética. Fuente: SuperManu, CC BY-SA 3.0. 11.4 Cómo se Produce y Transporta la Energía 11.4.1 Las Ondas Una onda se puede describir usando algunos atributos básicos (Figura 11.10): par(mar=c(3,3,3,3), cex=0.65) t &lt;- seq(0,20,0.025) y &lt;- sin(t) plot(t,y,type=&quot;l&quot;, xlab=&quot;time&quot;, ylab=&quot;Sine wave&quot;, lwd=1.75, bty=&quot;o&quot;, ylim=c(-1,1.25),xaxt = &quot;n&quot;, yaxt = &quot;n&quot;,col=&quot;gray70&quot;) segments(0,0,20,0,col=&quot;gray40&quot;,lwd=0.75, lty=1) arrows(1.5707,0.015,1.5707,0.98,col=&quot;gray20&quot;, lty=1, lwd=0.5,code=3,length = .05) #segments(1.5707*5,0,1.5707*5,1,col=&quot;gray60&quot;, lty=1, lwd=0.5) arrows(1.65,1,1.5707*5,1,col=&quot;gray20&quot;, lty=1, lwd=0.5,code=3,length = .05) text(1.5707*2.5 + 1, 1.15,expression(paste(&quot;Longitud de onda (&quot;, lambda,&quot;)&quot;)), srt=0) text(1.15,0.45,labels= c(&quot;Amplitud (A)&quot;), srt=90) segments(1.5707*10,-1,1.5707*10,1,col=&quot;gray60&quot;,lwd=0.5, lty=5) text(1.5707*10,1.1,expression(paste(&quot;Frecuencia (&quot;, nu,&quot;)&quot;)), srt=0) Figura 11.10: Descripción general de una onda. Amplitud (A): Distancia entre el punto central y la cresta (punto de altura máxima), la unidad depende del tipo de onda (m, v/m). Longitud de Onda (\\(\\lambda\\)): Distancia entre dos crestas o valles (punto de altura mínima), se mide en unidad de distancia (m, mm, \\(\\mu m\\)). Frecuencia (\\(\\nu\\)): Número de crestas que pasan por un punto dado por unidad de tiempo. La unidad de medida es el hercio (HZ), que equivale a un ciclo por segundo (un ciclo es el paso de dos crestas). Período (T): Tiempo transcurrido entre el paso de dos crestas por un punto. Fase (\\(\\varphi\\)): El ángulo de fase o fase de una onda se refiere a su desplazamiento hacia la derecha o la izquierda con respecto a una referencia. Se mide en grados (°) o radianes (rad). Algunas relaciones que se desprenden de esta descripción son: Frecuencia y Período son recíprocas entre sí: \\[\\begin{equation} \\nu= \\frac{1}{T} \\tag{11.1} \\end{equation}\\] La longitud de onda \\(\\lambda\\) y frecuencia \\(\\nu\\) están inversamente relacionadas: \\[\\begin{equation} c= \\lambda \\nu \\tag{11.2} \\end{equation}\\] Donde \\(c\\) es la velocidad de la luz en el vacío, ~\\(3 \\times 10^8 \\frac{m}{s}\\). 11.4.2 Cuantos y Dualidad de la Luz De acuerdo con la física clásica, la materia estaba compuesta por partículas que tenían masa, cuya posición en el espacio podía ser conocida; por otro lado, consideraban que las ondas luminosas no tenían masa, y que su posición en el espacio no podía ser determinada. Puesto que pensaban que pertenecían a diferentes categorías, los científicos no tenían una buena comprensión de cómo interactuaban la luz con la materia. Sin embargo, esto cambió en 1900, cuando el físico alemán Max Planck (Figura 11.11) comenzó a estudiar cuerpos negros (cuerpos que se calientan hasta que empiezan a brillar). Figura 11.11: Max Planck. Fuente: Bundesarchiv, Bild 183-R0116-504 CC-BY-SA 3.0. Planck encontró que la radiación electromagnética emitida por un cuerpo negro no podía ser explicada por la física clásica, que postula que la materia puede absorber y emitir cualquier cantidad de radiación electromagnética. Planck observó que, de hecho, la materia absorbía o emitía energía solo en múltiplos enteros del valor \\(h \\nu\\), donde \\(\\nu\\) es la frecuencia de la luz absorbida o emitida y \\(h\\) es la constante de Planck, \\(6.626 \\times 10^{-34}Js\\). Este fue un descubrimiento sorprendente, pues desafió la idea de que la energía era continua y que se podía transferir en cualquier cantidad. La realidad, que descubrió Planck, es que la energía no es continua, sino que está cuantizada (es decir, que solo puede transferirse en paquetes individuales o -partículas- de tamaño \\(\\nu h\\)). Cada uno de estos paquetes de energía es conocido como cuanto (cuantos, en plural). El descubrimiento de Planck de que la radiación electromagnética está cuantizada cambió para siempre la idea de que la luz se comporta solamente como onda. En realidad, parecía que la luz tenía tanto propiedades de onda como de partícula. 11.4.3 El Fotón Los descubrimientos de Planck pavimentaron el camino para el descubrimiento del fotón. El fotón es la partícula elemental, o cuanto, de la luz. Como pronto veremos, los átomos y las moléculas pueden absorber o emitir fotones. Cuando un átomo o una molécula absorbe un fotón, este le transfiere su energía. Ya que la energía está cuantizada, se transfiere toda la energía del fotón (recuerda que no puede transferirse en fracciones de cuantos, que son los paquetes de energía más pequeños posibles). El proceso inverso también es verdadero. Cuando un átomo o una molécula pierde energía, emite un fotón con exactamente la misma cantidad de energía que perdió. Este cambio en la energía es directamente proporcional a la frecuencia del fotón emitido o absorbido, y está dado por la famosa ecuación de Planck: \\[\\begin{equation} E= h \\nu \\tag{11.3} \\end{equation}\\] donde \\(E\\) es la energía del fotón absorbido o emitido (dada en joules, \\(J\\)), \\(\\nu\\) es la frecuencia del fotón (dada en hertz, \\(Hz\\)) y \\(h\\) es la constante de Planck (\\(6.626 \\times 10^{-34}Js\\)). 11.4.4 Relación entre Teoría Ondulatoria y Cuántica Ahora estamos listos para integrar las naturalezas ondulatoria y cuántica de la luz, el movimiento de toda partícula lleva asociada una onda de longitud \\(\\lambda\\) y de energía \\(E\\): De la ecuación (11.2) reorganizamos los componentes para expresar la frecuencia \\(\\nu\\) en función de la velocidad de la luz \\(c\\) y longitud de onda \\(\\lambda\\): \\[\\begin{equation} \\nu= \\frac{c}{\\lambda} \\tag{11.4} \\end{equation}\\] y reemplazamos en (11.3) tenemos la energía \\(E\\) de la partícula expresada en términos de dos constantes (\\(c\\) y \\(h\\)) y longitud de onda \\(\\lambda\\): \\[\\begin{equation} E= h \\frac{c}{\\lambda} \\tag{11.5} \\end{equation}\\] Y de la atenta observación de la formula resultante encontramos que a menor longitud de onda mayor energía y viceversa. 11.5 El Espectro Electromagnético El espectro electromagnético es el conjunto de todas las frecuencias posibles a las que se produce radiación electromagnética. El límite teórico inferior del espectro electromagnético es \\(0\\) (ya que no existen frecuencias negativas) y el teórico superior es \\(\\infty\\). Con los medios técnicos actuales, se han detectado frecuencias electromagnéticas inferiores a \\(30 Hz\\) y superiores a \\(2,9 \\times 10^{27} Hz\\). Aunque formalmente el espectro es infinito y continuo, se cree que la longitud de onda electromagnética (distancia entre dos valores de amplitud máxima de la onda) más pequeña posible es la longitud de Planck (\\(l_P \\approx 1,616252 \\times 10^{-35} m\\)), distancia o escala de longitud por debajo de la cual se espera que el espacio deje de tener una geometría clásica (medidas inferiores no pueden ser tratadas en los modelos de física actuales debido a la aparición de efectos de gravedad cuántica). Igualmente, se piensa que el límite máximo para la longitud de una onda electromagnética sería el tamaño del universo. En el paquete SpecHelpers Hanson (2017) encontramos la función emSpectrum() que dibuja un espectro electromagnético: SpecHelpers::emSpectrum(molecular = F, applications = T) Figura 11.12: Espectro Electromagnético. Gráfico generado por el paquete SpecHelpers. En orden decreciente de longitud de onda (y creciente de energía) encontramos las regiones llamadas ondas de radio, infrarrojo, luz visible, ultravioleta, rayos x y rayos gamma (ver Figura 11.12). Algunas de estas regiones del espectro son útiles para la EO. 11.5.1 Espectro Visible (VIS) La retina del ojo humano es sensible a las ondas electromagnéticas con frecuencias entre \\(0.4 - 0.7 \\mu m\\). Por lo tanto, esta banda de frecuencias se llama región visible del espectro electromagnético y coincide con las longitudes de onda donde la radiación solar es máxima. 11.5.2 Infrarrojo Cercano (NIR), Próximo o Reflejado La región del infrarrojo (IR) cercano NIR (del inglés near IR) \\(0.7 - 1.2 \\mu m\\). Esta parte del espectro se encuentra un poco más allá de la capacidad de percepción del ojo humano y a veces se conoce también como el infrarrojo reflectante o infrarrojo fotográfico, porque parte de este espectro (la región (\\(0.7 - 0.9 \\mu m\\)) se puede detectar con películas especiales. El NIR es de especial interés debido a su sensibilidad para determinar el estado fitosanitario. También permite diferenciar coberturas vegetales y contenidos de agua. 11.5.3 Infrarrojo Medio (MIR) Esta región espectral se encuentra entre las regiones NIR y TIR. De \\(1.2 - 8 \\mu m\\). la influencia de la energía del sol sigue siendo muy relevante, El intervalo entre \\(1.3 - 2.5 \\mu m\\) es denominado Infrarrojo de Onda Corta (SWIR) y es utilizado para estimar contenidos de humedad en vegetación y suelos. Esta región proporciona las mejores estimaciones del contenido de humedad del suelo y vegetación. De \\(3 - 8 \\mu m\\), la señal se vuelve una mezcla continua de energía reflejada por el sol y emitida por la superficie, convirtiéndose el componente emitido más relevante a medida que las longitudes de onda se hacen más largas. El intervalo de \\(3 - 5 \\mu m\\) es particularmente útil para detectar fuentes de altas temperaturas, como volcanes o incendios forestales. 11.5.4 Infrarrojo Térmico (TIR) Región \\(8 - 14 \\mu m\\). Este es emitido por la energía de superficie de la Tierra que se usa comúnmente para mapear las temperaturas de la superficie. La región termal ha sido ampliamente utilizada para detectar evapotranspiración (ET) vegetal, propiedades del hielo y las nubes, efectos del calor urbano y para la discriminación de rocas. 11.5.5 Microondas (MW) Para radiaciones superiores a \\(1 cm\\). Esta región espectral es donde funcionan los sistemas de radar. Su principal ventaja es la absorción atmosférica muy baja, lo que nos permite ver a través de las nubes. La radiación de MW también puede penetrar en las copas de los bosques a varias profundidades y muy útil en análisis de humedad del suelo y rugosidad superficial. Requiere de la emisión de un haz energético por parte del sensor. Las señales recibidas por un sensor en estas diferentes regiones espectrales varían con el tipo de cobertura terrestre y con las propiedades biofísicas y bioquímicas de los componentes de la superficie. Pero primero presentamos algunos de los conceptos básicos de energía y unidades de medida utilizados en teledetección para comprender mejor las propiedades características de mediciones espaciales. 11.6 Conceptos Básicos y sus Unidades 11.6.1 Ángulo Sólido El análisis de un campo de radiación a menudo requiere la consideración de la cantidad de energía radiante confinada a un elemento de ángulo sólido. Un ángulo sólido se define como la relación entre el área \\(o\\) de una superficie esférica interceptada en el centro del cuadrado de radio \\(r\\), como se indica en la figura 11.13 basada en Liou (2002). Puede escribirse como: \\[\\begin{equation} \\Omega = o / r^2 \\tag{11.6} \\end{equation}\\] Las unidades de ángulo sólido se expresan en términos de estereorradián (\\(sr\\)). Una esfera cuya área superficial es \\(4\\pi r^2\\) el ángulo sólido correspondiente sería de \\(4\\pi sr\\). Figura 11.13: Definición de ángulo sólido donde o es el área y r la distancia. 11.6.2 Magnitudes Radiométricas Una observación remota requiere una fuente de energía y un sensor que puede detectar dicha energía EM emitida (o reflejada) por la superficie de la Tierra hacia el campo de visión del sensor. La energía electromagnética (EEM) de interés tiene una cierta intensidad, composición espectral, y dirección (es decir, la energía puede dirigirse hacia o lejos de la superficie). A continuación, describimos las unidades comúnmente utilizadas en aplicaciones de EO. Las fórmulas para cada uno de estos términos energéticos se incluyen en el cuadro 11.1. Tabla 11.1: Magnitudes Físicas. Concepto Fórmula Unidad Energía Radiante (\\(Q\\)) julios (\\(J\\)) Flujo Radiante (\\(\\phi\\)) \\(\\partial Q/\\partial t\\) vatios (\\(W\\)) Irradiancia (\\(E\\)) \\(\\partial \\phi/\\partial A\\) \\(Wm^{-2}\\) Emitancia (\\(M\\)) \\(\\partial \\phi/\\partial A\\) \\(Wm^{-2}\\) Intensidad Radiante (\\(I\\)) \\(\\partial \\phi/\\partial \\Omega\\) \\(Wsr^{-1}\\) Radiancia (\\(L\\)) \\(\\partial I/\\partial A \\; cos(\\Theta)\\) \\(Wm^{-2}sr^{-1}\\) Radiancia Espectral (\\(L_{\\lambda}\\)) \\(\\partial L/\\partial_\\lambda\\) \\(Wm^{-2}sr^{-1}\\mu m^{-1}\\) Emisividad (\\(\\epsilon\\)) \\(M/M_n\\) Reflectividad (\\(\\rho\\)) \\(\\phi_r/\\phi_i\\) Absortividad (\\(\\alpha\\)) \\(\\phi_a/\\phi_i\\) Transmisividad (\\(\\tau\\)) \\(\\phi_t/\\phi_i\\) Nota: \\(t\\): Unidad de Tiempo. \\(A\\): Unidad de Área. \\(\\Omega\\): Ángulo sólido. \\(\\Theta\\): Ángulo entre dirección del flujo enegético y la normal. \\(\\phi_r\\): Flujo Reflejado. \\(\\phi_a\\): Flujo Absorbido. \\(\\phi_i\\): Flujo Incidente. \\(\\phi_t\\): Flujo Transmitido. Energía Radiante (\\(Q\\)): Medida en julios (\\(J\\)), es la unidad de energía más básica y se refiere a la energía total irradiada en todas las direcciones hacia superficie. Flujo Radiante (\\(\\phi\\)): medido en vatios (\\(W\\)), es la cantidad de julios por segundo (\\(J s^{-1} = W\\)) y representa la tasa de transferencia de energía en todas las direcciones por unidad de tiempo. Densidad de Flujo Radiante: es la tasa de transferencia de energía por unidad de área medida en vatios por metro cuadrado (\\(W m^{-2}\\)). Exitancia Radiante o Emitancia (\\(M\\)): es la densidad de flujo radiante que sale de la superficie en todas las direcciones por unidad de área y por unidad de tiempo (\\(W m^{-2}\\)). Irradiancia Radiante (\\(E\\)): es la densidad de flujo radiante que incide sobre la superficie por unidad de área y por unidad de tiempo (\\(W m^{-2}\\)). Es el mismo concepto que la emitancia, pero en este caso se refiere a la energía que llega a la superficie en lugar de aquella que sale de la superficie. Intensidad Radiante (\\(I\\)): es la energía total que sale de la superficie por unidad de tiempo y dentro de una unidad de ángulo sólido (\\(\\Omega\\)). Así, la intensidad radiante se mide en vatios por estereorradián (\\(W sr^{-1}\\)). Radiancia (\\(L\\)): es la energía total que sale en una determinada dirección por unidad de área y ángulo sólido. Es el término más fundamental en teledetección, ya que describe exactamente lo que mide el sensor. La radiancia es expresada en vatios por metro cuadrado por estereorradián (\\(W m^{-2} sr^{-1}\\)). Si expresamos la radiancia en función de las longitudes de onda a sensar podemos expresar como: \\[\\begin{equation} L\\left( \\lambda_1,\\lambda_2 \\right)= \\int_{\\lambda_1}^{\\lambda_2} L_\\lambda \\partial\\lambda \\tag{11.7} \\end{equation}\\] Donde vemos que es la integral (sumatoria continua) de energía entre dos longitudes de onda (rango válido del sensor). Así, los términos de energía anteriores también se pueden expresar en base a longitudes de onda y tienen el sufijo espectral aplicado a ellos, como radiancia o irradiancia espectral. Por ejemplo, el término radiación espectral, \\(L_{\\lambda}\\), se refiere a la producción de energía por una unidad de área por unidad de ángulo sólido y longitud de onda o \\(L_{\\lambda} = W m^{-2} sr^{-1} \\lambda^{-1}\\). De manera similar, la irradiancia espectral, \\(E\\lambda\\), se refiere a la energía incidente sobre una superficie por unidad de longitud de onda. También hay una serie de términos de energía adimensional, que varían de 0 a 1, que son ampliamente utilizados para caracterizar las propiedades espectrales de la superficie de la Tierra: Emisividad (\\(\\epsilon\\)): es la relación entre la salida radiante de un superficie (\\(M\\)) relativa a la de un emisor perfecto a la misma temperatura (\\(M_n\\)). Un emisor perfecto también se conoce como cuerpo negro y tiene emisividad 1. Los materiales naturales, por otro lado, son emisores imperfectos con emisividad van de 0 a &lt;1. Valores de emisividad en diferentes longitudes de onda son útiles para caracterizar materiales. Reflectividad (\\(\\rho\\)): es la relación entre la energía reflejada por una superficie y la energía incidente sobre esa superficie. Absortividad (\\(\\alpha\\)): es la relación entre la energía absorbida por la superficie y la energía incidente sobre esa superficie. Transmitividad (\\(\\tau\\)): es la relación entre la energía transmitida a través de una superficie y la energía incidente sobre esa superficie. Es importante destacar que por el principio de conservación de la energía tenemos la relación: \\[\\begin{equation} \\alpha + \\rho + \\tau = 1 \\tag{11.8} \\end{equation}\\] A estos términos sin unidades también se les puede agregar el sufijo espectral, como en la reflectancia espectral. Hay algunas relaciones útiles que se derivan de los términos energéticos mencionados anteriormente. El término albedo es la relación entre toda la energía saliente y la energía incidente para una superficie determinada. Más específicamente, albedo es la relación de la emitancia (\\(M\\)) sobre la irradiancia (\\(E\\)) sobre todas las longitudes de onda reflectantes solares o de onda corta y es el equivalente de la reflectancia hemisférica, es decir, la reflectancia integrada en todas las direcciones (Ecuación (11.9)). \\[\\begin{equation} ALBEDO= \\rho_{hemisferico} = \\frac{M}{E} \\tag{11.9} \\end{equation}\\] El albedo es una variable fundamental en estudios de balance energético, modelización climática y estudios de degradación del suelo. Albedo espectral se refiere a la salida dividida por la irradiancia para una banda espectral específica (Ecuación (11.10)). \\[\\begin{equation} ALBEDO\\;ESPECTRAL= \\rho_{hemisferico,\\lambda} = \\frac{M_\\lambda}{E_\\lambda} \\tag{11.10} \\end{equation}\\] Es importante tener en cuenta que un sensor satelital no mide las señales hemisféricas de la energía emitidas en todas las direcciones, sino que mide la radiancia espectral (\\(L\\lambda\\)) desde un campo de visión angular estrecho. La radiancia direccional espectral (\\(L\\lambda\\)) está relacionada con la emitancia espectral hemisférica (\\(M\\lambda\\)) de la siguiente forma (Slater (1980)): \\[\\begin{equation} M_\\lambda = \\pi L_\\lambda \\tag{11.11} \\end{equation}\\] De manera similar, las reflectancias de la superficie derivadas de las mediciones satélitales son reflectancias direccionales, ya que se refieren a una geometría de medición específica entre sensor de satélite y el Sol, en relación con la superficie. La relación entre el valor de radiancia espectral recibidos por un sensor de satélite (\\(L_{sen(\\lambda)}\\)) y la reflectancia espectral de superficie (\\(\\rho_\\lambda\\)) se convierte en: \\[\\begin{equation} \\rho_\\lambda = \\frac{\\pi L_\\lambda}{E_{0,\\lambda}} \\tag{11.12} \\end{equation}\\] donde \\(E_{0,\\lambda}\\) es la irradiancia solar que llega a la superficie. 11.6.3 Importancia de la Temperatura Figura 11.14: Fotografía de William Thomson, primer Barón Kelvin. Fuente: Librería Smithsoniana. Las temperaturas son expresadas en unidades Kelvin en honor al físico británico Willian Thomson primer Barón de Kelvin (Figura 11.14) quien determinó y fijó el cero absoluto en los \\(-273,15°C\\). La escala de temperatura de Kelvin constituye la escala natural en la que se anotan las ecuaciones termodinámicas y la unidad de temperatura en el Sistema Internacional de Unidades. 11.7 Radiación de Cuerpo Negro Figura 11.15: Idealización aproximada de un cuerpo negro como un pequeño agujero en un recinto aislado. Fuente:AG Caesar.Wikipedia. Las leyes de la radiación del cuerpo negro son básicas para comprender la absorción y procesos de emisión. Un cuerpo negro (Figura 11.15) es un concepto básico en física y se puede visualizar considerando una cavidad con un pequeño orificio de entrada. La mayoría del flujo radiante que ingresa a este orificio desde el exterior quedará atrapada dentro de la cavidad, independientemente del material y las características superficiales de la pared. Los reflejos se repiten internamente ocurren hasta que todos los flujos son absorbidos por la pared. La probabilidad de que cualquiera de los flujos entrantes escapará a través del orificio es tan pequeño que el interior aparece oscuro. El término cuerpo negro se utiliza para una configuración de material donde la absorción será completa. La emisión de un cuerpo negro es lo opuesto a la absorción. El flujo emitido por cualquier área pequeña de la pared se refleja repetidamente y en cada encuentro con la pared, el flujo es debilitado por la absorción y reforzado por una nueva emisión. Después de numerosos encuentros, la emisión y la absorción alcanzan una condición de equilibrio con respecto a la temperatura de la pared. A continuación, presentamos cuatro leyes fundamentales que gobiernan la radiación del cuerpo negro, comenzando con la ley de Planck. 11.7.1 Ley de Planck La cantidad de energía que contiene un flujo radiante es inversamente proporcional a su longitud de onda. La distribución espectral de dicha radiación EM emitida por un cuerpo negro (un emisor perfecto) se puede caracterizar por la ley de radiación de Planck (Figura 11.11) como sigue: \\[\\begin{equation} M_{n,\\lambda} = \\frac{C_1}{\\lambda^5 e^{\\left({\\frac{c_2}{\\lambda T}}\\right)} -1} \\tag{11.13} \\end{equation}\\] Donde: \\(M_{n,\\lambda} (W \\; m^{-2} \\; \\mu m^{-1})\\) indica la emitancia espectral en una longitud de onda \\(\\lambda\\) en \\(\\mu m\\). Constantes \\(C_1 = 3,741 \\times 10^8 \\; W m^{-2} \\mu m^4\\) y \\(C_2 = 1,438 \\times 10^4 \\; \\mu m \\;K\\). \\(T\\) temperatura en \\(K\\). Esta ecuación describe la distribución espectral de salida de un cuerpo negro a cierta temperatura como una curva suave con un único máximo (Figura 11.16). La ecuación indica que cualquier objeto más caliente que el cero absoluto (\\(-273,15 °C\\)) emite energía radiante y que la energía aumenta en proporción a su temperatura. blackBodyRadiationColors &lt;- function(x, max_value=1) { foo &lt;- colorRamp(c(rgb(0,0,0),rgb(1,0,0),rgb(1,1,0),rgb(1,1,1)))(x*max_value)/255 apply(foo,1,function(bar)rgb(bar[1],bar[2],bar[3])) } col &lt;- blackBodyRadiationColors(seq(0,0.6,length.out=7)) x=seq(0.1,100,by=0.01) f=function(x,T){3.741e8/(x^5*(exp(1.438e4/(x*T))-1))} par(mar=c(5,8,3,3)) y= f(x,288) plot(x,y, type = &quot;l&quot;, xlim=c(0.1,100), ylim=c(1,1e9), log=&quot;xy&quot;, col=col[2], axes=F, xlab=expression(paste(lambda, &quot;(&quot;,mu, &quot;m)&quot;)), ylab=&quot;&quot;) axis(2,at= c(1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000), labels= c(&quot;1&quot;, &quot;10&quot;, &quot;100&quot;, &quot;1.000&quot;, &quot;10.000&quot;, &quot;100.000&quot;, &quot;1.000.000&quot;, &quot;10.000.000&quot;, &quot;100.000.000&quot;), las=2) mtext(text = expression(paste(&quot;Emitancia Espectral (W&quot;,m^-2,mu,m^-1,&quot;)&quot;)), side = 2, line = 6) axis(1,at= c(.1,0.4, 0.7, 1.2, 8, 14, 100), labels= c(&quot;0.1&quot;,&quot;0.4&quot;,&quot;0.7&quot;, &quot;1.2&quot;,&quot;8.0&quot;, &quot;14.0&quot;, &quot;100.0&quot;), las=1) y= f(x,500) points(x,y, type=&quot;l&quot;, col=col[3]) y= f(x,1000) points(x,y, type=&quot;l&quot;, col=col[4]) y= f(x,2000) points(x,y, type=&quot;l&quot;, col=col[5]) y= f(x,4000) points(x,y, type=&quot;l&quot;, col=col[6]) y= f(x,5778) points(x,y, type=&quot;l&quot;, col=col[7]) text(7,40,&quot;TIERRA (288 K)&quot;, col=col[2]) text(4,650,&quot;500 K&quot;, col=col[3]) text(2,20000,&quot;1.000 K&quot;, col=col[4]) text(1,700000,&quot;2.000 K&quot;, col=col[5]) text(0.5,20000000,&quot;4.000 K&quot;, col=col[6]) text(0.3,140000000,&quot;SOL (5.778 K)&quot;, col=col[7]) Figura 11.16: Curvas de Emitancia Espectral de Cuerpo Negro a varias temperaturas. Veamos un caso práctico, la temperatura promedio del planeta tierra se ha fijado en \\(288 K\\) y podemos calcular usando la ley de Planck las longitudes de onda dónde se produce el máximo de energía radiante: t_k &lt;- 288 lambda &lt;- seq(8,15,1) M &lt;- 3.741e8/(lambda^5 * (exp(1.438e4/(lambda * t_k))-1)) names(M) &lt;- lambda round(M,3) ## 8 9 10 11 12 13 14 15 ## 22.275 24.778 25.556 25.082 23.816 22.113 20.225 18.312 Encontramos el máximo de energía radiante entorno a los \\(11 \\; \\mu m\\) que cae dentro del rango del espectro que hemos denominado TIR o infrarrojo térmico (ver 11.5.4). Y en el caso de sol cuya temperatura estimada es \\(5778 K\\): t_k &lt;- 5778 lambda &lt;- seq(0.0,2,0.5) M &lt;- 3.741e8/(lambda^5 * (exp(1.438e4/(lambda * t_k))-1)) names(M) &lt;- lambda round(M/1e6,0) ## 0 0.5 1 1.5 2 ## NaN 83 34 12 5 Encontramos los máximos de energía radiante en las longitudes de onda del rango visible (ver 11.5.1) e infrarrojo cercano (ver 11.5.2). 11.7.2 Ley de Desplazamiento de Wien El sol como fuente primaria de energía se encuentra a una temperatura de aproximadamente 5778 K y de acuerdo a la ley de radiación del cuerpo negro de Planck (ver 11.7) donde se relaciona la cantidad energía que emite un cuerpo con la distribución espectral (longitudes de onda de los máximos (Figura 11.16), caen en el que llamamos espectro visible (ver 11.5.1) y por eso nuestra visión se ha adecuado precisamente a ese rango. Figura 11.17: Wilhelm Wien, físico esloveno, fuente: nobelprize.org. La superficie terrestre tal como se ve en la figura 11.16 tiene sus máximos alrededor de las longitudes de onda en el rango 8  14 \\(\\mu m\\) identificado anteriormente como TIR (ver 11.5.4). Como se aprecia en estos ejemplos, la temperatura es clave al momento de definir el máximo de emitancia de un objeto (por lo tanto, el mejor rango de longitud de onda para diseñar nuestro sensor) ya que todo objeto con temperatura superior a los \\(0 \\; K\\) emite energía, requisito básico para ser percibido por dicho sensor. La ley de desplazamiento de Wien (Figura 11.17) establece que la longitud de onda de la intensidad máxima de la radiación del cuerpo negro \\(\\lambda_{max}\\) es inversamente proporcional a la temperatura: par(mar=c(4,4.5,2,0),cex=1) f=function(x,T){3.741e8/(x^5*(exp(1.438e4/(x*T))-1))} x=seq(0.1,5,by=0.05) y= f(x,4000) plot(x,y, type = &quot;l&quot;, xlim=c(0,10), ylim=c(0,1e8), col=col[2], axes=F, xlab=expression(paste(lambda, &quot;(&quot;,mu, &quot;m)&quot;)), ylab=expression(paste(&quot;Emitancia Espectral (W&quot;,m^-2,mu,m^-1,&quot;)&quot;))) axis(2,at= c(0, 1e7,5e7,1e8,5e8), labels= c(&quot;0&quot;, &quot;1e7&quot;, &quot;5e7&quot;, &quot;1e8&quot;, &quot;5e8&quot;), las=2) #mtext(text = expression(paste(&quot;Emitancia Espectral (W&quot;,m^-2,mu,m^-1,&quot;)&quot;)), side = 2, line = 3) axis(1,at= 0:5, las=1) y= f(x,5000) points(x,y, type=&quot;l&quot;, col=col[4]) y= f(x,6000) points(x,y, type=&quot;l&quot;, col=col[6]) text(2,16000000,&quot;4.000 K&quot;, col=col[2]) text(2,43000000,&quot;5.000 K&quot;, col=col[4]) text(2,101500000,&quot;6.000 K&quot;, col=col[6]) Figura 11.18: Longitud de Onda y Emitancia Espectral de Cuerpo Negro a varias temperaturas. \\[\\begin{equation} \\lambda_{max} =\\frac{2.897,6 \\; \\mu m \\;K}{T} \\tag{11.14} \\end{equation}\\] Donde \\(T\\) es la temperatura en unidades Kelvin. La dependencia de la posición de la intensidad máxima de la temperatura es evidente a partir de las curvas de cuerpo negro que se muestran en la figura 11.18. Si la temperatura del sol la estimamos en 6000 K (la fotosfera) encontramos el pico de longitud de onda \\(\\lambda_{max}\\) es: t_sol &lt;- 6000 l_max &lt;- 2898 / t_sol l_max ## [1] 0.483 Valor expresado en \\(\\mu m\\) (Lo ubica dentro del rango visible del espectro). 11.7.3 Ley de Stefan-Boltzmann Para conocer el total de la energía radiante espectral de un cuerpo negro se debe integrar la curva de Planck sobre el dominio de las longitudes de onda de \\(0\\) a \\(\\infty\\). Figura 11.19: Joef Stefan, físico esloveno, fuente: Grabado por K. Schönbauer. \\[\\begin{equation} M(T) = \\sigma \\; T^4 \\tag{11.15} \\end{equation}\\] Donde \\(\\sigma\\) es la constante de Stefan-Boltzmann: \\(5,67 \\times 10^{-8} \\; W \\; m^{-2} \\; K^{-4}\\) y la temperatura \\(T\\) en Kelvin. La ley fue deducida en 1879 por el físico austriaco Joef Stefan (Figura 11.19) y la ley fue derivada en 1884 a partir de consideraciones teóricas por Ludwig Boltzmann (Figura 11.20). Figura 11.20: Ludwig Eduard Boltzmann, físico austríaco, fuente: Universität Wien. La emitancia total de un objeto es función de su temperatura. Pequeños cambios en la temperatura suponen cambios notables en su emitancia radiante. Debido a esta dependencia en la cuarta potencia, la emisión de radiación por los cuerpos terrestres cambia considerablemente durante el día o a través de las estaciones. 11.7.4 Ley de Kirchhoff Las tres leyes fundamentales anteriores se refieren a la intensidad radiante emitida por un cuerpo negro, que depende de la longitud de onda emisora y la temperatura del medio. Un medio puede absorber radiación de una longitud de onda particular, y al mismo tiempo también emiten radiación de la misma longitud de onda. La razón a la cual la emisión toma lugar es función de la temperatura y la longitud de onda. Esta es la propiedad fundamental de un medio en condiciones de equilibrio termodinámico. La declaración física en cuanto a absorción y emisión fue propuesta por primera vez por el físico Alemán Gustav Kirchhoff (Figura 11.21). Figura 11.21: Gustav Robert Kirchhoff fuente: Librería Smithsoniana. Para comprender el significado físico de la ley de Kirchhoff, consideremos un recinto aislado con paredes negras. Suponga que este sistema ha alcanzado el estado de equilibrio termodinámico caracterizado por una temperatura uniforme y una radiación isotrópica. Debido a que las paredes son negras, la radiación emitida por el sistema es absorbido por las paredes. Además, debido a que existe un equilibrio, la misma cantidad de radiación absorbida por las paredes también es emitida. Dado que el cuerpo negro absorbe el máximo posible radiación, tiene que emitir la misma cantidad de radiación. Si emitiera más, el equilibrio no sería posible y esto violaría la segunda ley de la termodinámica. La radiación dentro del sistema se conoce como radiación de cuerpo negro como ya se ha mencionado, y la cantidad de intensidad radiante es una función de la temperatura y longitud de onda. Sobre la base de la discusión anterior, la emisividad de una longitud de onda dada, \\(\\epsilon_\\lambda\\), de un medio es igual a la absortividad, \\(\\alpha_\\lambda\\) \", de ese medio en equilibrio termodinámico. Por lo tanto, podemos escribir: \\[\\begin{equation} \\epsilon_\\lambda = \\alpha_\\lambda \\tag{11.16} \\end{equation}\\] Un medio con una absortividad \\(\\alpha_\\lambda\\) absorbe solo \\(\\alpha_\\lambda\\) veces la intensidad radiante del cuerpo negro, por lo tanto, emite \\(\\epsilon _\\lambda\\) veces la intensidad radiante del cuerpo negro. Si en la ecuación (11.8) en su versión espectral, hacemos la transmitividad \\(\\tau_\\lambda = 0\\) (suponiendo un objeto opaco) y usando \\(\\epsilon_\\lambda = \\alpha_\\lambda\\) reemplazamos resulta: \\[\\begin{equation} \\rho_\\lambda + \\epsilon_\\lambda = 1 \\tag{11.17} \\end{equation}\\] Entonces, para mantener el equilibrio térmico, el exceso de energía absorbida debe ser emitido: Las superficies con alta reflectividad espectral (por ejemplo, nieve) son muy poco emisivas. Las superficies con baja reflectividad espectral (agua) son muy emisivas. "],["flujo.html", "Capítulo 12 EEM 12.1 Flujo de la EEM 12.2 Interacción EEM con la Atmósfera 12.3 Últimos pasos", " Capítulo 12 EEM 12.1 Flujo de la EEM En la teledetección como en la EO, la energía que emana de la superficie de la tierra se mide utilizando un sensor montado en una plataforma de aeronave o nave espacial. Esa medida se usa para construir una imagen del paisaje debajo de la plataforma. En principio, cualquier energía procedente de la superficie terrestre puede utilizarse para formar una imagen. La mayoría de las veces se refleja la luz del sol, por lo que la imagen grabada es, en muchos sentidos, similar a la vista que tendríamos de la superficie de la tierra desde un avión, aunque las longitudes de onda utilizadas en la teledetección suelen estar fuera del alcance de la visión humana. La energía recibida también podría provenir de la propia tierra que actúa como un radiador debido a su propia temperatura. Alternativamente, podría ser energía que se dispersa hasta el sensor al haber sido irradiado a la superficie por una fuente artificial, como un láser o un radar. Siempre que se disponga de una fuente de energía, se podría utilizar casi cualquier longitud de onda para imaginen las características de la superficie terrestre. Sin embargo, existe una limitación, particularmente cuando se toman imágenes de altitudes de las naves espaciales. La atmósfera terrestre no permite el paso de radiación en todas las longitudes de onda. Energía en algunas longitudes de onda son absorbidas por los constituyentes moleculares de la atmósfera. Las longitudes de onda para las que hay poca o ninguna absorción atmosférica forman las que son llamadas ventanas atmosféricas (ver 12.2.2) y encontramos cierto número de dichas ventanas en las regiones visible e infrarroja del espectro. Las longitudes de onda utilizadas para la obtención de imágenes en la teledetección están claramente restringidas a estas ventanas atmosféricas. Incluyen las llamadas longitudes de onda ópticas que cubren el visible y el infrarrojo, las longitudes de onda térmicas y las longitudes de onda de radio que se utilizan en imágenes de radar y microondas pasivas de la superficie terrestre. Figura 12.1: Esquema básico del flujo de la EEM en la EO. Basado en Olaya [2020] Cualquiera que sea el rango de longitud de onda que se utilice para obtener imágenes de la superficie terrestre, el sistema es muy complejo, basado en Olaya (2020) podemos distinguir a los menos tres elementos principales en el ciclo o flujo de la EEM. Siguiendo la figura 12.1 encontramos: Una Fuente de radiación (A), que puede ser de origen natural o artificial. La radiación emitida por dicha fuente viaja a través de un medio gaseoso, la atmósfera (C) y llega a la superficie terrestre (B) y sufre perturbaciones causadas por los elementos presentes en ella. Los propios objetos pueden ser también emisores de radiación que nuevamente viajan por la atmósfera (C) hasta el receptor (D). 12.2 Interacción EEM con la Atmósfera 12.2.1 La Atmósfera library(ggplot2) library(ggthemes) # Standard Atmosphere Calculator # 1.Standard sea level conditions (h = 0) ---- temp0 &lt;- 288.16 pres0 &lt;- 1.01325 * 10^5 dens0 &lt;- 1.2250 grav0 &lt;- 9.80665 radius &lt;- 6378136.3 gasc &lt;- 287.0368 # 2.Standard Atmosphere Results ----- # 0:11k - first gradient layer h1 &lt;- seq(0, 11000, by = 100) h1.calc &lt;- h1 - 0 a1 &lt;- -6.5 * 10^-3 t1 &lt;- temp0 + a1 * h1.calc p1 &lt;- pres0 * (t1/temp0)^(-grav0/(a1*gasc)) d1 &lt;- dens0 * (t1/temp0)^(-((grav0/(a1*gasc))+1)) # 11.1k:25k - first isothermal layer h2 &lt;- seq(11100, 25000, by = 100) h2.calc &lt;- h2 - 11000 t2 &lt;- rep(216.66, length(h2)) p2 &lt;- 22631.5 * exp(-(grav0/(gasc*t2))*h2.calc) d2 &lt;- .3639048 * exp(-(grav0/(gasc*t2))*h2.calc) # 25.1k:47k - second gradient layer h3 &lt;- seq(25100, 47000, by = 100) h3.calc &lt;- h3 - 25000 a3 &lt;- 3 * 10^-3 t3 &lt;- 216.66 + a3 * h3.calc p3 &lt;- 2488.504 * (t3/216.66)^(-grav0/(a3*gasc)) d3 &lt;- .04001407 * (t3/216.66)^(-((grav0/(a3*gasc))+1)) # 47.1k:53k - second isothermal layer h4 &lt;- seq(47100, 53000, by = 100) h4.calc &lt;- h4 - 47000 t4 &lt;- rep(282.66, length(h4)) p4 &lt;- 120.4327 * exp(-(grav0/(gasc*t4))*h4.calc) d4 &lt;- 0.001484340 * exp(-(grav0/(gasc*t4))*h4.calc) # 53.1k:79k - third gradient layer h5 &lt;- seq(53100, 79000, by = 100) h5.calc &lt;- h5 - 53000 a5 &lt;- -4.5 * 10^-3 t5 &lt;- 282.66 + a5 * h5.calc p5 &lt;- 58.31566 * (t5/282.66)^(-grav0/(a5*gasc)) d5 &lt;- 0.0007187439 * (t5/282.66)^(-((grav0/(a5*gasc))+1)) # 79.1K:90k - third isothermal layer h6 &lt;- seq(79100, 90000, by = 100) h6.calc &lt;- h6 - 79000 t6 &lt;- rep(165.66, length(h6)) p6 &lt;- 1.009319 * exp(-(grav0/(gasc*t6))*h6.calc) d6 &lt;- 2.122580e-05 * exp(-(grav0/(gasc*t6))*h6.calc) # 90.1k:105K - fourth gradient level h7 &lt;- seq(90100, 105000, by = 100) h7.calc &lt;- h7 - 90000 a7 &lt;- 4 * 10^-3 t7 &lt;- 165.66 + a7 * h7.calc p7 &lt;- .1044209 * (t7/165.66)^(-grav0/(a7*gasc)) d7 &lt;- 2.195954e-06 * (t7/165.66)^(-((grav0/(a7*gasc))+1)) # 5. Plot Data ---- # consolidate data std.atmos &lt;- data.frame(hg = c(h1, h2, h3, h4, h5, h6, h7), temp = c(t1, t2, t3, t4, t5, t6, t7) - 273.15, pres = c(p1, p2, p3, p4, p5, p6, p7), dens = c(d1, d2, d3, d4, d5, d6, d7)) std.atmos.thin &lt;- std.atmos[seq(0, 1e3, by = 20),] par(mfrow = c(2, 1)) plot( std.atmos.thin$pres, std.atmos.thin$hg, type = &quot;l&quot;, xlim = c(-10, 1e5), ylim = c(0, 1e5), axes = F, xlab = expression(paste(&quot;Presión (hPa)&quot;)), ylab = &quot;Altitud (km)&quot;, lwd = 3, col = &quot;gray80&quot; ) axis(1, at = seq(0, 8e4, 2e4),labels = seq(0, 800, 200),las = 1) axis(2,at = seq(0, 1e5, 1e4), labels = seq(0, 100, 10), las = 2) segments(0,9600,8e4,9600,lty = 2,col = &quot;gray40&quot;,lwd = 0.5) segments(0,49600,8e4,49600,lty = 2,col = &quot;gray40&quot;,lwd = 0.5) segments(0,83300, 8e4,83300,lty = 2,col = &quot;gray40&quot;,lwd = 0.5) text( 8e4,13000,&quot;Límite Tropopausa&quot;, adj = 1,cex = 0.9,font = 4, col = &quot;steelblue4&quot;) text( 8e4,53000,&quot;Límite Estratopausa&quot;,adj = 1,cex = 0.9,font = 4, col = &quot;steelblue4&quot;) text( 8e4,86700,&quot;Límite Mesopausa&quot;, adj = 1, cex = 0.9, font = 4, col = &quot;steelblue4&quot;) plot( std.atmos.thin$temp,std.atmos.thin$hg,type = &quot;l&quot;, xlim = c(-120, 30), ylim = c(0, 1e5), axes = F, xlab = &quot;Temperatura (°C)&quot;,ylab = &quot;Altitud (km)&quot;,lwd = 3,col = &quot;gray80&quot;) axis(1, at = seq(-120, 30, 30), las = 1) axis( 2,at = seq(0, 1e5, 1e4),labels = seq(0, 100, 10), las = 2) segments(-120, 9600,30, 9600,lty = 2,col = &quot;gray40&quot;,lwd = 0.5) segments(-120, 49600, 30, 49600,lty = 2,col = &quot;gray40&quot;,lwd = 0.5) segments(-120, 83300, 30, 83300,lty = 2, col = &quot;gray40&quot;, lwd = 0.5) text( -120, 13000,&quot;Límite Tropopausa&quot;,adj = 0,cex = 0.9,font = 4, col = &quot;steelblue4&quot;) text( -120, 53000,&quot;Límite Estratopausa&quot;, adj = 0,cex = 0.9, font = 4, col = &quot;steelblue4&quot;) text( 30, 86700,&quot;Límite Mesopausa&quot;, adj = 1, cex = 0.9, font = 4, col = &quot;steelblue4&quot;) Figura 12.2: Modelo Atmósfera Estándar, Presión (superior) y Temperatura (inferior) versus Altitud. El \\(97\\%\\) de la masa atmosférica se encuentra entre la superficie terrestre y los \\(25 \\; km\\) de altura. La densidad varía a medida que ascendemos producto de la gravedad, menor presión a medida que ascendemos (Figura 12.2, superior). La temperatura varía con la altitud debido a la presión, en la troposfera la temperatura disminuye con la altitud, en la estratosfera la temperatura permanece constante para luego aumentar con la altitud, en la mesósfera disminuye, en la termósfera aumenta con la altitud (Figura 12.2, inferior). La atmósfera se compone principalmente de gases como el \\(N_2\\;(78\\%)\\), \\(O_2\\;(21 \\%)\\), \\(Ar\\;(0,9\\%)\\), \\(CO_2\\;(0,03\\%)\\), algunas trazas de gases nobles y Ozono (\\(O_3\\)), también vapor de agua (\\(H_2O\\)) y Aerosoles: partículas sólidas como humo o polvo o partículas líquidas dispersas en el medio gaseoso como gotas de agua. Y todo el conjunto reduce el total de energía incidente de \\(\\sim 340 \\;W m^{-2}\\) a sólo \\(\\sim 173 \\;Wm^{-2}\\) que llegan a la superficie terrestre. En conjunto todos estos fenómenos deben ser considerados al momento de interpretar las señales de respuestas de los objetos y la superficie terrestre capturados en los sensores correspondientes. Vamos a clasificar en tres los efectos de la atmósfera: Absorción de EEM en determinadas bandas del espectro (ver figura 12.3). Dispersión de determinadas magnitudes de longitud de onda causadas por los aerosoles y nubes. Emisión de EEM por cualquier cuerpo sobre el cero absoluto adicionales al flujo radiante del sol. 12.2.2 Absorción La absorción implica que algunas moléculas presentes en la atmósfera absorben algunas longitudes de onda, quedando el resto intactas. Las tres moléculas presentes en la atmósfera que contribuyen en mayor medida a la absorción de radiación son el ozono (\\(O_3\\)), el dióxido de carbono (\\(CO_2\\))y el vapor de agua (\\(H_20\\)). El ozono absorbe radiación en el rango del ultravioleta. Este tipo de radiación resulta perjudicial para los seres humanos, por lo que la desaparición del ozono causaría que la luz del sol produjese quemaduras en nuestra piel. El dióxido de carbono absorbe radiación en el rango del infrarrojo. Este tipo de radiación está asociada a fenómenos térmicos, por lo que el gas contribuye a que cierta cantidad de calor quede atrapado en la atmósfera. El vapor de agua absorbe principalmente microondas, y su distribución varía enormemente a lo largo del planeta. En las capas de aire por encima de un desierto, por ejemplo, hay una cantidad muy pequeña de vapor de agua, mientras que sobre los trópicos esta cantidad es mucho más grande. par(mar = c(4, 5, 4, 0), cex.axis = .9, cex.lab = 1.1) plot( xy, type = &quot;l&quot;, axes = F, ylim = c(0, 1), lwd = 2, col = &quot;gray50&quot;, xlab = &quot;Moléculas Absorbentes&quot;, ylab = &quot;Transmitancia (%)&quot; ) lbl &lt;- c( expression(O[2]), &quot;&quot;, &quot;&quot;, expression(paste(H[2], O)), &quot;&quot;, expression(paste(H[2], O)), expression(CO[2]), expression(paste(H[2], O)), expression(CO[2]), expression(paste(&quot; &quot;, O[3])), expression(paste(H[2], O)), expression(paste(CO[2], &quot; &quot;)), expression(paste(&quot; &quot;, O[3])), expression(paste(H[2], O)), expression(CO[2]), expression(CO[2]) ) axis(1, at = mol, labels = lbl) axis(2, at = seq(0, 1, .1), labels = seq(0, 100, 10)) axis(3, at = c(0.2, 0.8, 1.4, 8, 14), labels = c(&quot;0.4&quot;, &quot;0.7&quot;, &quot;1.2&quot;, &quot;8.0&quot;, &quot;14.0&quot;), las = 1, cex = 0.9 ) mtext( expression(paste( &quot;Longitud de Onda (&quot;, lambda, &quot; &quot;, paste(mu, m), &quot;)&quot; )), side = 3, line = 2, cex = 1.2, las = 1) Figura 12.3: Transmitancia de la atmósfera terrestre y su relación con las moléculas absorbentes. La existencia de moléculas en la atmósfera capaces de absorber radiación electromagnética limita el rango de longitudes de onda que pueden aplicarse a la medición remota de propiedades atmosféricas. Las zonas del espectro en las que no se produce absorción se suelen denominar ventanas atmosféricas (Figura 12.3). En dichas ventanas la transmitancia de la atmósfera terrestre es máxima. En la parte inferior de la figura se indican las moléculas de gas presentes en la atmósfera y su ubicación relativa de aquellas longitudes de onda que son absorbidas. Mientras que en la parte superior se representan las longitudes de onda límite de las zonas que hemos estudiado. 12.2.3 Dispersión La dispersión de la EEM es causada por el reflejo de la radiación solar entrante por gases, aerosoles y vapor de agua presentes en la atmósfera. Como resultado, la radiación detectada por el sensor es una mezcla de energía reflejada tanto por la superficie como por la atmósfera, por lo tanto, contiene un ruido indeseable que se debe eliminar durante la recuperación de las propiedades superficiales. En la superficie, la irradiancia directa se reduce, mientras que la difusa aumenta el resplandor (procedente de otros objetos). Los aerosoles se originan tanto por causas naturales como humanas. Pueden ser oceánicos, causado por el movimiento del agua, o continental, como en polvo en suspensión o partículas emitidas por combustión. Debido a que estas partículas atmosféricas son muy variables en el tiempo y espacio, la corrección de la dispersión atmosférica es bastante problemática. Sin embargo, este factor se debe tener en cuenta siempre que se realice una estimación precisa de la radiancia del suelo. Se requiere corregir, por ejemplo, cuando las medidas desde el satélite se comparan con las mediciones radiométricas terrestres o cuando intentamos detectar cambios entre dos imágenes adquiridas con varios años de diferencia. Normalmente, las mediciones atmosféricas in situ no están disponibles en tiempos de adquisición de satélites y, por lo tanto, la corrección de la atmósfera a menudo debe depender de datos extraídos de la propia imagen. Algunos métodos pueden implicar cambios en la reflectancia. Según su origen y las características de los aerosoles, varían mucho en tamaño, lo que causa diferentes tipos de dispersión, ya que este proceso es altamente dependiente del diámetro de las partículas dispersas (Figura 12.4) basada en Richards (2013)). Los tres tipos principales de dispersión atmosférica son: Rayleigh que es causada por partículas más pequeñas que la longitud de onda de la radiación. Mie cuando la partícula es de tamaño similar a la longitud de onda. No Selectiva cuando el tamaño de la partícula es mayor que la longitud de onda. Figura 12.4: Dispersión atmosférica y de partículas. Modificado de Richards(2013) La dispersión de Rayleigh depende en gran medida de la longitud de onda y afecta principalmente a las bandas más cortas. Provoca, por ejemplo, el color azul del cielo porque el azul es la longitud de onda más baja del espectro VIS. La dispersión de Mie también depende de la longitud de onda de la radiación entrante, aunque en menor grado que la dispersión de Rayleigh. Aerosoles y polvo atmosférico son la principal causa de este tipo de dispersión, aunque también es causada por los incendios forestales o neblina costera. Finalmente, la dispersión no selectiva afecta por igual a varias longitudes de onda. Es decir, dispersan las diferentes bandas del espectro VIS de forma similar por ejemplo, las nubes y la niebla tienden a aparecer en tonos grises ya dispersan todos los colores. 12.2.4 Emisión También hay influencias de las emisiones atmosféricas que son importantes principalmente en el rango termal (TIR). Esta debe corregirse para obtener con precisión la temperatura de la superficie a partir de imágenes adquiridas por satélite. Todos los materiales con una temperatura superior al cero absoluto, incluyendo la atmósfera emiten energía radiante que viajará en la dirección del sensor y será detectado. Así, al igual que con la dispersión atmosférica, la señal de la emisión de la atmósfera debe ser separada de la señal térmica que emite la superficie (Figura ). Figura 12.5: Emisión TIR, adicional a la emisión general. Imagen Sentinel-2 sobre el cráter Puu Oo del complejo volcánico Kilauea (23 mayo 2018), fuente: ESA. 12.3 Últimos pasos Luego de este recorrido de la EEM desde el emisor hasta la superficie terrestre y de regreso al sensor montado en un vehículo espacial cruzando la atmósfera y sufriendo todos los efectos que hemos descrito la EEM impacta en un sensor electrónico y almacena esa magnitud convertida en un valor numérico. Finalmente, el receptor retransmite la información a la tierra y la data capturada va a generar como producto final una imagen (un objeto ráster), en cuyas celdas o píxeles va a contener un valor que representan la intensidad de la radiación. El almacenamiento de datos en unidades de radiancia es difícil y, por lo tanto, los sensores traducen la radiancia medida en números o niveles digitales (DN). Por lo tanto, el rango de energía medido por el sensor se divide en distintas unidades (los números o niveles digitales). La calibración específica del sensor determina la cantidad mínima y máxima de radiación que se puede medir. Los DN expresan la cantidad de radiación en relación con estos coeficientes de calibración específicos del sensor. El número total de DN posibles es lo que denominamos resolución radiométrica (ver 13.3) del sensor. 12.3.1 DN a TOA Como los DN dependen de la calibración del sensor, a mediciones idénticas producen diferentes DN entre los sensores. Los DN no son físicamente significativos. En lugar de DN, a menudo nos interesa la reflectancia. La reflectancia expresa la fracción de radiación reflejada en relación con la energía entrante total (es decir, del sol) y se escala entre 0 y 1. Muchas aplicaciones requieren datos convertidos a reflectancia y / o corregidos por la influencia de la atmósfera (Figura 12.6). Los siguientes pasos son necesarios para convertir DN a (corregido atmosféricamente) reflectancia del fondo de la atmósfera (BOA): Calibración del sensor (DN a radiancia). Conversión a reflectancia en la parte superior de la atmósfera (radiancia a TOA). Corrección atmosférica que produce reflectancia del fondo de la atmósfera (TOA a BOA). Se puede realizar fácilmente una conversión de DN en luminosidad. Teniendo en cuenta las geometrías de los sensores solares y la irradiancia solar, podemos inferir fácilmente la reflectancia de la parte superior de la atmósfera (TOA) a partir de la radiación. Esto facilita, por ejemplo, una comparación de medidas de diferentes sensores. En la práctica, esto implica un escalado lineal de los valores DN que utiliza dos factores de cambio de escala específicos de la banda. Uno es multiplicativo, uno es aditivo (ver un caso práctico en las imágenes Landsat en ??). Con los datos de Landsat Colección 2 Nivel 2 (ver ??) (¡este no es el caso para todos los sensores!), Podemos usar un solo conjunto de coeficientes para convertir DN directamente a reflectancia TOA. 12.3.2 TOA a BOA La corrección atmosférica es el paso final hacia mediciones comparables de la superficie de la Tierra. Al hacer la corrección atmosférica, (teóricamente) eliminamos la influencia de la atmósfera. Por lo tanto, llamamos al producto reflectancia del fondo de la atmósfera (BOA). En teoría, el BOA medido por un sensor espacial debería ser comparable a las mediciones terrestres. En el caso práctico de las imágenes Landsat Colección 2 Nivel 2 (ver ??) los pasos descritos ya han sido realizados y toda la data disponible está procesada a nivel de BOA. Figura 12.6: Comparación BOA-TOA. Imagen Landsat 8 RGB, TOA (izquierda). BOA (derecha). Área en Nepal mayo3, 2013 (fuente: Michelle Bouchard, USGS) "],["prop-img.html", "Capítulo 13 Resoluciones de Imagen 13.1 Resolución Espacial 13.2 Resolución Espectral 13.3 Resolución Radiométrica 13.4 Resolución Temporal 13.5 Resolución angular", " Capítulo 13 Resoluciones de Imagen Las especificaciones técnicas de la plataforma espacial y las del sensor mismo determina las resoluciones, espacial, espectral, radiométrica, angular y temporal (Liang and Wang (2020)) de los datos sensados. Los distintos tipos de resolución están estrechamente interconectados. La adquisición de imágenes de alta resolución espacial suele implicar reducir la resolución temporal y/o resolución espectral. Las limitaciones en la transmisión de datos o grabación a bordo, un sensor será capaz de optimizar solo uno o dos de los tipos de resolución. Incrementar cualquiera de los cinco tipos de resoluciones implica una considerable cantidad de transmisión y procesamiento de datos adicionales, tanto para el sensor como las instalaciones terrestres de recepción. La misión de un sistema de teledetección intenta enfatizar la resolución particular que mejor se adapta a sus requisitos. Si el sistema está diseñado para detectar fenómenos dinámicos, una buena cobertura temporal es fundamental, incluso sacrificando la resolución espacial (satélites meteorológicos). Si la misión está orientada a la exploración minera, los detalles espectrales y espaciales son más importantes, mientras que la cobertura temporal se vuelve menos significativa. Finalmente, identificar la calidad de un sensor basado en su resolución espacial es muy simplista. Se requiere una alta resolución espacial para ciertas aplicaciones (por ejemplo, cartografía urbana o agrícola), pero puede ser secundaria para otras aplicaciones, como detección de incendios o estudios geológicos, evaluación de riesgos naturales, por ejemplo, requieren una alta resolución temporal, al igual que el pronóstico del clima. Otras aplicaciones de teledetección deben optimizar la resolución espectral, como en la estimación de la productividad de los cultivos o la demanda de agua. En consecuencia, el tipo de resolución prioritaria es fundamental para seleccionar el sensor más adecuado para una aplicación particular. 13.1 Resolución Espacial La resolución espacial es la medida más pequeña de un objeto que puede ser resuelto (capacidad de separar objetos cercanos y que aparezcan independientes y aislados) por el sensor, o el área del suelo en el campo instantáneo de vista o (instantaneous field of view, IFOV)15 del sensor, o la dimensión lineal en el suelo representado por cada píxel. La resolución espacial de los sensores electrónicos ópticos depende de la altura orbital, número de detectores, longitud focal y configuración del sistema. Los sensores de observación de la Tierra en funcionamiento cubren una amplia gama de resoluciones espaciales (ver cuadro ). Alta con un tamaño de píxel de \\(0.5 - 4.0 \\;m\\). Media con un tamaño de píxel de \\(10 - 60 \\; m\\). Gruesa con un tamaño de píxel de \\(100 - 1000 \\; m\\). Muy Gruesa con un tamaño de píxel de \\(10 - 50 \\; km\\). Sensores orientados a aplicaciones globales tienen un tamaño de píxel entre \\(200 - 1000 \\; m\\) y sensores orientado al estudio atmosférico suelen tener una resolución espacial muy gruesa \\(10 - 50 \\;km\\). La resolución espacial juega un papel importante en la interpretación de imágenes porque afecta el nivel de detalle alcanzado. Solo puede identificar objetos varias veces más grande que el tamaño del píxel, aunque se pueden detectar características más pequeñas cuando existe suficiente contraste radiométrico entre el objeto y el fondo (por ejemplo, un incendio de alta temperatura puede detectarse incluso si su tamaño es sólo un pequeño proporción del área total de píxeles). La selección de la resolución espacial más conveniente está estrechamente relacionada con la escala adecuada para el problema particular en estudio. Además, resolución espacial afecta la pureza de señal de píxel. Cuanto menor sea el tamaño del píxel, menor será la probabilidad de que el píxel sea una combinación de dos o más tipos de cobertura. Un píxel mixto probablemente tendrá una señal promedio de las coberturas terrestres presentes dentro del IFOV. Como resultado, ese píxel puede no parecerse a ninguna de las categorías que componen la mezcla, lo que hará su identificación más difícil. Tabla 13.1: Resoluciones de las misiones y sensores cuyos productos serán descritos y procesados con R en el texto y en éste sitio web. Nivel Satélite Sensor Bits Días Período Espacial Bandas Gruesa Terra/Aqua MODIS 12 1 1999- 250 B1-B2 Gruesa Terra/Aqua MODIS 12 1 1999- 500 B3-B7 Gruesa Terra/Aqua MODIS 12 1 1999- 1000 B8-B36 Gruesa Sentinel-3 SLSTR 16 1 2016- 300 LST Gruesa Sentinel-5p TROPOMI 16 1 2018- 1100 VARIOS Media Landsat 9 OLI-2 TIR-2 14 16 2021- 30 B1-B9,B10-B11 Media Landsat 8 OLI TIRS 16 16 2013- 30 B1-B7,B10 Media Landsat 7 ETM+ 16 16 1999- 30 B1-B6 Media Landsat 5 TM 16 16 1984-2012 30 B1-B6 Media Landsat 4 TM 16 16 1982-1993 30 B1-B6 Media Sentinel 2/2A MSI 12 5 2015- 60 B1,B9,B10 Media Sentinel 2/2A MSI 12 5 2015- 10 B2-B4,B8 Media Sentinel 2/2A MSI 12 5 2015- 20 B5-B7,B8a,B11-B12 Nota: Los productos Landsat (1-9) hacen referencia al nuevo set distribuido Level-2 Science Products. 13.2 Resolución Espectral La resolución espectral se refiere al número de bandas proporcionadas por el sensor y sus anchos de banda espectrales. En términos generales, un sensor proporcionará una mejor capacidad de discriminación a medida que se adquieren más bandas. Idealmente, esas bandas espectrales deberían ser lo suficiente estrechas como para identificar características de absorción específicas que de otra manera podrían verse borrosas. Entre los sistemas de satélites EO, la peor resolución espectral se encuentra en las imágenes denominadas pancromáticas (una sola banda, escala de grises) o imágenes en color RGB (tres bandas, Red, Green, Blue). Los sensores remotos espaciales son generalmente: pancromáticas una banda (generalmente de mayor resolución espacial. multiespectral capturan algunas pocas bandas, entre \\(4 - 7\\). hiperespectrales decenas o centenas de bandas. ultraespectrales con miles de bandas. En la actualidad se trabaja en el diseño y pruebas de sensores de este tipo. Entra las mayores resoluciones entre los sensores de satélites EO se encuentra el Hyperion a bordo del satélite EO-1 con 220 bandas que cubren de \\(0.4\\) a \\(2.5\\;\\mu m\\). El espectrómetro de imágenes Visible/infrarrojo aerotransportado de la NASA AVIRIS tiene 224 bandas con una cobertura espectral similar. La selección del número de bandas, ancho y rango espectral medido por el sensor está relacionada con los objetivos que se espera alcanzar. Mientras aplicaciones para la minería requieren múltiples bandas en los rangos del infrarrojo visible, cercano y medio, sensor satelital meteorológico puede requerir solo una o dos bandas en el rango visible y varias docenas en los canales infrarrojos medios para estimar la composición del gas atmosférico. Figura 13.1: Firmas Espectrales en Imágen Pancromática, Multi e Hiperespectral para cuatro coberturas de suelo. 13.2.1 Firma Espectral En la figura 13.1 vemos la importancia de una alta resolución espectral Cada elemento sobre la superficie terrestre tiene una respuesta única a las distintas longitudes de onda, esa forma específica es una firma del material y física del componente, es lo que denominamos firma espectral. Entonces, para una imagen con una mayor cantidad y más finas bandas podemos revisar más fielmente esas formas y compararlas con extensas librerías e identificar los objetos de estudio. Figura 13.2: Sitio Web del Proyecto Librería Espectral ECOSTRESS de la NASA. Los científicos han creado extensas librerías con datos espectrales para distintas coberturas o grupos de materiales para ser usados como referencias, entre ellas vamos a destacar la Biblioteca Espectral ASTER Versión 2, (speclib.jpl.nasa.gov), proyecto desarrollado por Meerdink et al. (2019) y Baldridge et al. (2009) (Figura 13.2). La biblioteca espectral ASTER proporciona una colección completa de miles de espectros compuesto por una amplia variedad de materiales naturales y artificiales que cubren la longitud de onda rango \\(0,4\\mu m - 15,4\\mu m\\). La versión 2.0 de la biblioteca espectral ASTER se lanzó el 3 de diciembre de 2008. La biblioteca espectral ASTER incluye datos de otras tres bibliotecas espectrales: Biblioteca espectral de la Universidad Johns Hopkins (JHU). Laboratorio de propulsión a chorro (JPL). Biblioteca espectral del Servicio Geológico de los Estados Unidos (USGS - Reston). Figura 13.3: Ficha de descarga de archivos de librerías. Figura 13.4: Formulario de contacto para informar los archivos solicitados. La biblioteca de espectros se proporciona con más de seis mil espectros individuales. Para su descarga debemos seguir algunos pasos preliminares: Visitar el sitio web de la librería speclib.jpl.nasa.gov. (Figura 13.2). Visitar la ficha Download para explorar las alternativas disponibles de descarga (Figura 13.3). Previo a la descarga se debe llenar un formulario de contacto y solicitar los archivos a descargar, y en el correo electrónico entregado se recibirá el enlace correspondiente. (Figura 13.4). En cuestión de minutos, se recibe el correo de acuso recibo con el resumen de la orden y aviso de que se trabaja en ello. Y finalmente se recibe el correo con el enlace de descarga (Figura 13.5). Figura 13.5: Correo con link de descarga. 13.2.2 Import Dataset Es importante destacar que los archivos de las firmas espectrales se componen de información general respecto a los datos, o técnicos de la captura entre otros. A continuación, un número variable de registros en formato de dos columnas, en la primera longitud de onda (en \\(\\mu m\\)) y un valor de reflectancia (en %), separados por espacio usando símbolo decimal el punto (.). Es un formato complejo para una carga directa ya que debemos separar la cabecera de los datos y luego cada registro separar en dos valores numéricos con valores decimales. Para resolver estos casos, RStudio ofrece una forma interactiva para la carga de datos: Import Dataset, opción en la barra de herramientas de la ficha Environment (Figura 13.6). De las alternativas disponibles utilizaremos una función más completa que la disponible en los paquetes base de R mediante el paquete readr. Figura 13.6: Detalle de opción Importar Datos Externos. Activando la opción se presenta un cuadro de dialogo con varios grupos de opciones para seleccionar, configurar, cargar directo a un objeto R a la sesión o generar el código R para pegar en un archivo script. El primer paso es seleccionar el archivo de texto buscando el archivo con el botón Browse (Figura 13.7). Figura 13.7: Detalle de opciones para buscar o escribir el nombre del archivo a leer. Una vez seleccionado, el sistema puede tardar unos segundos en responder y nos entrega una vista preliminar del contenido en un panel dedicado (Figura 13.8), que responde dinámicamente a los cambios en los parámetros de lectura disponibles en la parte inferior del cuadro de dialogo. Figura 13.8: Detalle de opción Importar Datos Externos. Los parámetros más importantes para la lectura son: Figura 13.9: Detalle de opción Importar Datos Externos con los parámetros usados para cargar nuestro archivo de texto. Name: Modificar el nombre del objeto por uno compatible con los nombres R. Skip: Número de líneas de texto al inicio que no son datos. Ellas son ignoradas. Delimiter: Carácter o símbolo que se usa en el archivo para separar los datos en columnas. Los parámetros ideales para la lectura de los archivos de firmas espectrales descargados del sitio de la NASA se pueden revisar en la figura 13.9. Finalmente, existen dos formas de rescatar los datos (Figura 13.10): Importar el Objeto: a la sesión actual como un dataframe mediante el botón Import. Copiar el código: Mediante el ícono se copia al clipboard y usando la combinación CNTRL+V para pegar en el script o consola. Figura 13.10: Detalle de las opciones para importar los datos a nuestra sesión R. 13.2.3 Procesando en R El código generado con la ayuda del cuadro de dialogo se copia en nuestro script y se puede modificar ligeramente para refinar el objeto y mejorar la usabilidad posterior. Primero se debe cargar el paquete que contiene la función: library(readr) Pasamos el nombre del archivo a leer a una variable para facilidad de reusabilidad. nombre_file &lt;- &quot;vegetation.tree.acacia.caven.vswir.jpl139.jpl.asd.spectrum.txt&quot; También asignamos los nombres de las columnas. aromo &lt;- read_table(here(&quot;speclib&quot;,&quot;ecospeclib-all&quot;, nombre_file), col_names = c(&quot;wavelength&quot;,&quot;reflectance&quot;), col_types = cols(wavelength = col_double(), reflectance = col_double()), skip = 20) Expresamos en formato gráfico para revisar la firma espectral propiamente tal (Figura 13.11). Figura 13.11: Firma Espectral del Árbol Acacia Caven (Aromo), librería ASTER v2. par(mfrow = c(3, 1), mar=c(5,5,5,5), cex.axis=1, cex.lab=1) plot(vegeta_sli[1:335,1:2], col = &quot;forestgreen&quot;, type = &quot;l&quot;, lwd=2,xlim=c(0.25,2.5), ylim=c(0,100),xlab=expression(paste(&quot;Longitud de Onda (&quot;,paste(mu,m),&quot;)&quot;)),ylab=&quot;Reflectancia (%)&quot;) lines(vegeta_sli[1:335,c(1,3)], col = &quot;chocolate1&quot;,lwd=2) lines(vegeta_sli[1:335,c(1,4)], col = &quot;olivedrab1&quot;, lwd=2) lines(vegeta_sli1[1:870,c(1,2)], col = &quot;wheat3&quot;, lwd=2) legend(x=&quot;topright&quot;, legend=c(&quot;Conífera&quot;,&quot;Caduco&quot;,&quot;Pasto Verde&quot;,&quot;Pasto Seco&quot;), fill=c(&quot;forestgreen&quot;,&quot;chocolate1&quot;,&quot;olivedrab1&quot;,&quot;wheat3&quot;)) plot(agua_sli[1:335,c(1,2)], col = &quot;skyblue1&quot;, type = &quot;l&quot;, lwd=2,xlim=c(0.25,2.5), ylim=c(0,100),xlab=expression(paste(&quot;Longitud de Onda (&quot;,paste(mu,m),&quot;)&quot;)),ylab=&quot;Reflectancia (%)&quot;) lines(agua_sli1[1:1110,c(1,2)], col = &quot;blue&quot;, lwd=2) lines(agua_sli2[1:395,c(1,2)], col = &quot;mediumslateblue&quot;, lwd=2) lines(agua_sli2[1:430,c(1,3)], col = &quot;lightblue1&quot;, lwd=2) legend(x=&quot;topright&quot;, legend=c(&quot;Hielo&quot;,&quot;Agua Pura&quot;, &quot;Nieve Gruesa&quot;,&quot;Nieve Fina&quot;), fill=c(&quot;skyblue1&quot;,&quot;blue&quot;,&quot;mediumslateblue&quot;,&quot;lightblue1&quot;)) plot(roca_sli[1:535,c(1,20)], col = &quot;snow4&quot;,type=&quot;l&quot;, lwd=2,xlim=c(0.25,2.5), ylim=c(0,100),xlab=expression(paste(&quot;Longitud de Onda (&quot;,paste(mu,m),&quot;)&quot;)),ylab=&quot;Reflectancia (%)&quot;) lines(roca_sli[1:535,c(1,35)], col = &quot;darkslategray4&quot;, lwd=2) lines(suelo_sli[1:1160,c(1,13)], col = &quot;chocolate4&quot;, lwd=2) lines(suelo_sli[1:1160,c(1,19)], col = &quot;sienna3&quot;, lwd=2) legend(x=&quot;topright&quot;, legend=c(&quot;Basalto&quot;,&quot;Fosforita&quot;,&quot;Lodo Obscuro&quot;,&quot;Arcilla Gris&quot;), fill=c(&quot;snow4&quot;,&quot;darkslategray4&quot;,&quot;chocolate4&quot;,&quot;sienna3&quot;)) Figura 13.12: Ejemplos de firmas espectrales organizadas por grupos de tipos de cobertura. 13.3 Resolución Radiométrica La resolución radiométrica denota la sensibilidad del sensor, es decir, su capacidad para discriminar pequeñas variaciones en la radiación espectral registrada. En los sensores electrónicos ópticos, la imagen es adquirida digitalmente y su resolución radiométrica se expresa comúnmente como el rango de valores utilizados para codificar la radiancia de entrada o, más precisamente, como el número de bits utilizados para almacenar la señal de entrada. Un sistema de sensor de 8 bits puede discriminar 256 radiancias de entrada diferentes por píxel (\\(2^8 = 256\\)), por lo tanto, un rango de números digitales (DN) que va de 0 a 255 (Figura 13.13). Figura 13.13: Comparación resoluciones radiométricas. debido a la mayor velocidad de la transmisión de datos y su almacenamiento, la resolución radiométrica de los sensores está aumentando. Anteriormente, la mayoría de los sensores proporcionaban Codificación de 8 bits, mientras que hoy en día varios tienen entre 11 y 16 bits por píxel (¡uno de 65536 valores!), por ejemplo, GeoEye, WorldView, MODIS o Landsat 8 OLI. La resolución radiométrica es más crítica en el análisis digital que en el visual. El número de niveles de gris que el ojo humano es capaz de discernir no supera los 64, y no puede distinguir más de 200.000 colores. Parece redundante tener incluso 256 valores digitales por banda (\\(16.8\\) millones de valores en una imagen en color de tres bandas). Sin embargo, cuando la interpretación es digital, las computadoras aprovechan todo el rango, en cuyo caso una alta resolución radiométrica es importante para discriminar objetos con firmas espectrales similares, lo que no sería posible con sensores menos sensibles. 13.4 Resolución Temporal La resolución temporal se refiere a la frecuencia de observación (período de revisión) proporcionada por el sensor. Este ciclo es función de las características orbitales del satélite (altura, velocidad y declinación), así como del FOV16 del sensor. Sensores con alta resolución temporal tienen una resolución espacial gruesa, ya que podrán observar una mayor área en cada adquisición de imágenes. En consecuencia, también tienen un campo de visión amplio, que implica problemas geométricos, ya que la misma área se puede observar desde muy diferentes ángulos en un breve tiempo diario, ver 13.5. Si el sensor observa un área más pequeña (campo de visión más estrecho), necesitará más órbitas para repetir la misma área observada y así, las capturas tendrán mayores períodos de tiempo. Para aliviar este problema, algunos sensores pueden hacer observaciones fuera del nadir, detectando áreas adyacentes a la órbita (las capacidades de apuntar generalmente van de \\(0°\\) a \\(20°\\)). Este es el caso de las cámaras a bordo de los satélites SPOT o WorldView. Una alternativa a los sensores que miran el nadir es tener varios satélites con las mismas características. Este es el caso de la constelación RapidEye (propiedad de una empresa privada), que proporciona una frecuencia de adquisición global diaria con una resolución espacial de \\(6.5 \\; m\\) utilizando cinco satélites. La resolución temporal de los sistemas de sensores EO varía según los objetivos de la misión. Los satélites meteorológicos observan fenómenos muy dinámicos y, por lo tanto, proporcionan la resolución temporal más alta: los satélites geoestacionarios pueden adquirir imágenes cada 15 o 30 minutos, y los satélites en órbita polar, como la NOAA (Estados Unidos), METOP (Europa) o Fengyun (China), proporcionan al mundo cobertura cada \\(12\\;h\\). Normalmente, los sensores de mayor resolución espacial ofrecen menor tiempo resoluciones, de 16 días (como el caso de la serie Landsat) a 28 días (para Radares ERS). Sin embargo, existe una tendencia creciente a tener una mayor resolución incluso para satélites de resolución espacial media o alta. Por ejemplo, el satélite Sentinel-2 de la Agencia Espacial Europea (ESA) proporcionará entre \\(10\\) y \\(60\\;m\\) imágenes de resolución para 13 canales espectrales cada 2 a 5 días cuando los dos satélites de la constelación están activos. 13.5 Resolución angular El concepto de resolución angular es muy reciente y se refiere a la capacidad del sensor para hacer observaciones de la misma área, desde diferentes ángulos de visión (Diner et al. (1999)). Las variaciones en reflectancia con ángulos de visión e iluminación variables se denominan función de distribución de reflectancia bidireccional (BRDF). Y para modelar estos efectos es necesario observar la superficie desde diferentes direcciones. También, las observaciones multiangulares son de gran interés en estimar algunas propiedades atmosféricas como el espesor de la capa de aerosoles o la altura de las nubes. El IFOV Se mide en metros en el suelo, y depende de la distancia focal de la cámara y la altura de la cámara sobre el suelo. Se define como la sección angular observada por el sensor en un momento dado en el tiempo. El campo de visión total (field of view, FOV) es el área observada por el satélite en una sola imagen. "],["mis-spa.html", "Capítulo 14 MISIONES ESPACIALES 14.1 Plataforma Búsqueda y Descarga", " Capítulo 14 MISIONES ESPACIALES 14.1 Plataforma Búsqueda y Descarga El sitio web que centraliza el acceso a datos de la NASA y otros productos espaciales es: earthexplorer.usgs.gov. Pasos principales para la descarga de imágenes: El sitio se compone de dos unidades principales, la zona de configuración de la búsqueda (panel izquierdo) y el mapa interactivo para definir el área geográfica de estudio (Figura 14.1). Figura 14.1: Vista principal earthexplorer.usgs.gov Si no se ha realizado el registro previo, debe realizar el proceso paso a paso (con la ayuda del mismo sitio) o logearse mediante el botón apropiado ubicado en la esquina superior derecha (Figura 14.2). Figura 14.2: Ventana de Login o de Registro, paso obligatorio. Configurar la búsqueda espacial (Figura 14.3 zona A y B): Usar servicios de geocodificación (para EE.UU.) convirtiendo una dirección postal en coordenadas geográficas o para el resto del mundo buscar por nombres propios o tipo de elemento geográfico. También se puede utilizar archivos kml generado en la aplicación Google Earth Pro o archivos shapefile estándar en las aplicaciones genéricamente denominadas SIG. Figura 14.3: Parámetros para crear y refinar una búsqueda, detalles en texto. Definir la zona geográfica por coordenadas y configurar el método de obtención de coordenadas o el formato de ingreso de los textos. En la ficha Polygon usar la opción Use Map y automáticamente la vista actual del mapa (sector derecho) se convierte en la zona geográfica de búsqueda. El listado de vértices puede ser editado, corregido, agregar o eliminar puntos mediante la interfaz o modificando directamente las marcas en el mapa arrastrándolas a su nueva ubicación. El siguiente método disponible es agregar el centro y radio de un círculo que delimita el espacio geográfico. Además, se pueden agregar parámetros no espaciales (Figura 14.3 zona C): Rango Temporal mediante el uso de calendario de inicio y fin (Figura 14.4). Figura 14.4: Opciones para refinar la búsqueda, fecha inicial y final. También puede filtrar los meses específicos para realizar la búsqueda (Figura 14.5). Figura 14.5: Lista para seleccionar meses particulares. Otro parámetro muy importante es fijar el porcentaje de cobertura nubosa que se define como el porcentaje del área que cubre la imagen se encuentra obstruida por nubes (Figura 14.6). Figura 14.6: Porcentaje de cobertura nubosa aceptable para las imágenes seleccionadas. El siguiente paso es la definición del tipo de datos. En la plataforma existe un gran número de misiones, sensores y tipos de datos, figura 14.7 MODIS (izquierda), Landsat (derecha). La plataforma permite selección múltiple. En el listado vamos a ubicar el grupo NASA LPDAAC Collections y dentro de las opciones, MODIS Land Surface Reflectance- V6. En las alternativas disponibles para este grupo de productos encontramos el grupo que corresponde al producto descrito en , MOD09A1 v6 del sensor MODIS. También encontramos los productos de la misión Landsat 4-5, 7-9 (Figura 14.7, derecha) que revisaremos en detalle en el punto . Figura 14.7: Lista de tipos de datos disponibles para descarga de la misión MODIS (izquierda) y Landsat (derecha). Figura 14.8: Mensaje que alerta de la realización de la consulta y botón para cancelar. Finalmente, para realizar la búsqueda se debe presionar el botón Results &gt;&gt;, y mientras se despliega el mensaje de búsqueda se podrá cancelar para redefinir o corregir algún parámetro (Figura ). Figura 14.9: Resultado de la búsqueda. Detalle de imágenes que cumplen los criterios definidos. 14.1.1 Descarga de Datos El resultado final es una lista interactiva con todos los productos que cumplen los parámetros de búsqueda. Para cada uno de ellos se disponen de varias opciones (Figura 14.9). Figura 14.10: Opciones Disponibles en archivo seleccionados. De izquierda a derecha, las opciones son (Figura 14.10): Silueta Gráfica de la extensión espacial. Visualización Baja Resolución en su ubicación exacta. Imagen para comparación entre productos seleccionados en nueva ventana. Visualizar Metadatos y detalles técnicos de la imagen. Descarga Directa (Figura 14.11) del archivo a disco local. Excluir de Descarga Figura 14.11: Opciones de descarga (depende del producto o tipo de datos a descargar, en el ejemplo MODIS). El primer sensor que vamos a estudiar es el sensor MODIS y las imágenes del set MOD09A1. Descargamos de la lista de opciones las cuatro imágenes más actualizadas que cubran el país de Niger con una baja cobertura nubosa (Figura 15.6): MOD09A1.A2021185.h18v07.061.2021194052227.hdf MOD09A1.A2021193.h18v06.061.2021202214452.hdf MOD09A1.A2021193.h19v06.061.2021202214223.hdf MOD09A1.A2021193.h19v07.061.2021202220423.hdf "],["modis.html", "Capítulo 15 Misiones MODIS 15.1 Terra y Aqua 15.2 MOD09A1 15.3 MODIS en R", " Capítulo 15 Misiones MODIS 15.1 Terra y Aqua MODIS o espectrorradiómetro de imágenes de resolución moderada es un instrumento clave a bordo de los satélites Terra (originalmente conocido como EOS AM-1) y Aqua (originalmente conocido como EOS PM-1). La órbita de Terra alrededor de la Tierra está programada para que pase de norte a sur a través del ecuador por la mañana, mientras que Aqua pasa de sur a norte sobre el ecuador por la tarde. Terra MODIS y Aqua MODIS están viendo toda la superficie de la Tierra cada 1 o 2 días, adquiriendo datos en 36 bandas espectrales o grupos de longitudes de onda (consulte las Especificaciones técnicas de MODIS). Estos datos mejorarán nuestra comprensión de la dinámica y los procesos globales que ocurren en la tierra, en los océanos y en la atmósfera inferior. Figura 15.1: Satélite Terra. NASA. Figura 15.2: Satélite Aqua. NASA. Las plataformas Terra y Aqua son parte del Sistema de Observación de la Tierra (EOS) de la NASA, Terra se lanzó con éxito en diciembre de 1999 y se encuentra en una órbita casi polar, sincrónica con el Sol, cruzando el ecuador alrededor de las 10:30 a.m. y p.m. La altura orbital es de 705 km, con un período de 98,88 min y un ciclo de repetición de 16 días. Lleva cinco sensores (MODIS, CERES, MISR, MOPITT y ASTER) diseñado para observaciones globales de tierras, océanos y variables atmosféricas. Aqua se lanzó en mayo de 2002 y tiene características orbitales similares a Terra, pero con un retraso de 3 horas, por tanto, cruza el ecuador a la 1:30 y a las 13:30. Este satélite lleva seis sensores (AIRS, AMSR-E, CERES, HSB y MODIS), con una configuración de instrumentos orientado a estudios oceanográficos. El sensor principal a bordo de las dos plataformas es MODIS. Adquiere datos diarios de todo el mundo en 36 bandas espectrales, a diferentes resoluciones, 250 a 1000 m. Las primeras dos bandas tienen una resolución espacial más fina (250 m) e incluyen el rojo y el espectro NIR. Longitudes de onda para monitorear la actividad de la vegetación. Se adquieren otras cinco bandas a 500 m de resolución que cubren el visible y SWIR y están destinados principalmente a la captura de propiedades de vegetación, nieve y suelo. El resto de las bandas tienen 1000 m de resolución y cubren longitudes de onda adicionales en el visible, MIR y TIR. La franja cubierta por MODIS es de 2300 km, y la frecuencia de observación es diaria (dos veces cuando se contabilizan los dos satélites). El programa MODIS se construyó para obtener radiancias (\\(\\rho\\)) calibradas y otros productos finales. Estos productos se agrupan en tres dominios: Productos Atmosféricos, incluyendo aerosoles, agua total precipitable, nubes y perfiles atmosféricos. Productos de Tierra, incluida la reflectancia de la superficie, temperatura de la superficie, la cobertura del suelo, índices de vegetación, incendios activos, radiación incidente, evapotranspiración, productividad de la planta, albedo, áreas quemadas, manto de nieve y hielo marino. Productos Oceánicos, que incluyen temperatura del mar, concentración de clorofila-a, partículas de carbono, fluorescencia y radiación fotosintética incidente. Existe una amplia serie de productos disponibles, todos ellos se encuentran detallados en el sitio de la NASA dedicado al sensor MODIS: modis.gsfc.nasa.gov/data/dataprod/index.php#atmosphere. A continuación, vamos a trabajar con el producto MOD09, productos MODIS Surface Reflectance proporcionan una estimación de la reflectancia espectral de la superficie tal como se mediría a nivel del suelo en ausencia de dispersión o absorción atmosférica. En el producto de 8 días, cada píxel de reflectancia de la superficie contiene la mejor observación posible durante un período de 8 días, según se selecciona en función de la alta cobertura de observación, el ángulo de visión bajo, la ausencia de nubes o sombras de nubes y la carga de aerosoles. 15.2 MOD09A1 Los productos MOD09A1, versión 6 (Vermote (2015)) que proporciona una estimación de la reflectancia espectral superficial de las bandas Terra de 1 a 7 corregidas para condiciones atmosféricas como gases, aerosoles y dispersión de Rayleigh (Figura 15.3 y el cuadro 15.1). Figura 15.3: Distribución y espesor de bandas en sensor MODIS. Tabla 15.1: Resumen de Bandas MODIS. Nombre Archivo Bandas(\\(rho\\)nm) Nombre Escala sur_refl_b01 B1(\\(620-670\\)) Red 0.0001 sur_refl_b02 B2(\\(841-876\\)) NIR 0.0001 sur_refl_b03 B3(\\(459-479\\)) Blue 0.0001 sur_refl_b04 B4(\\(545-565\\)) Green 0.0001 sur_refl_b05 B5(\\(1230-1250\\)) SWIR1 0.0001 sur_refl_b06 B6(\\(1628-1652\\)) SWIR2 0.0001 sur_refl_b07 B7(\\(2105-2155\\)) SWIR3 0.0001 sur_refl_qc_500m QA N/A sur_refl_szen \\(\\zeta \\; Solar\\) 0.01 sur_refl_vzen \\(\\zeta \\; Vista\\) 0.01 sur_refl_raz Az. relativo 0.01 sur_refl_state_500m Estados N/A sur_refl_day_of_year DOY píxel N/A Nota: \\(rho\\): Reflectancia Superficial. \\(zeta\\): ángulo Cenital. \\(DOY\\): Día del Año. (Day Of Year) Junto a las siete bandas de reflectancia de \\(500\\;m\\) hay dos capas de calidad y cuatro bandas que describen el momento de la observación. Para cada píxel se selecciona un valor de todas las capturas dentro del período compuesto de 8 días. Los criterios para la elección de píxeles incluyen la nube y el cenit solar. Cuando varias adquisiciones cumplen los criterios, se utiliza el píxel con el valor mínimo del canal 3 (azul). La colección de imágenes se extiende desde el 2000-02-24 hasta el presente con cobertura global y una frecuencia de 8 días. El píxel tiene un tamaño de \\(500\\;m\\) en imágenes de \\(2400\\times2400\\) filas y columnas en el sistema de coordenadas Sinusoidal, (EPSG: 6974). Código proyección: Proj4js.defs[SR-ORG:6974] = +proj=sinu +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs 15.3 MODIS en R Una vez descargadas las imágenes vamos a utilizar los paquetes rgdal (Bivand, Keitt, and Rowlingson (2021)) que agrega la capacidad de leer un archivo en formato _*.hdf_,17 y el paquete MODIS (Mattiuzzi and Detsch (2021)) que nos da acceso a la metadata, maneja los formatos de nombre de imágenes entre otros detalles prácticos. Luego de instalar ambos paquetes desde la consola, debe cargarlo en memoria (no olvidar agregar al inicio de su script): library(rgdal) library(MODIS) Construimos un vector con los archivos que cumplan con el formato hdf de nuestra carpeta de datos: archivos &lt;- list.files(path = here(&quot;raw&quot;,&quot;modis&quot;), pattern = &quot;*.hdf&quot;, full.names = T) Usando la función extractDate() del paquete MODIS podemos extraer la fecha de captura de los datos a partir del nombre de archivo. (datos &lt;- MODIS::extractDate(files = archivos[1], asDate = T)) Cada archivo hdf contiene al menos 13 capas de información (ver cuadro ) y usando la función getSds() obtenemos una lista con los nombres propios de cada capa y la ruta completa para llegar al archivo hdf. Por definición la función procesa un hdf en cada llamado, así que debemos envolver con el comando lapply (ver detalles en ) nuestra lista de archivos y la función a aplicar: imgs &lt;- lapply(archivos, getSds) Ahora tenemos estructurado por cada archivo las capas que contiene siguiendo el formato: imgs[[1]]$SDS4gdal[1] [1] HDF4_EOS:EOS_GRID:\"C:/Users/danilo.verdugo/Documents/ rasterEdu/raw/modis/MOD09A1.A2021185.h18v07.061.2021194052227.hdf \":MOD_Grid_500m_Surface_Reflectance:sur_refl_b01 Los archivos son leídos directamente con la función readGDAL() y convertidos a formato ráster directamente: r &lt;- readGDAL(imgs[[1]]$SDS4gdal[1]) raster(r) Ahora podemos reescribir este comando R para cada imagen por cada cada capa (\\(4 \\times 8\\)) veces o escribir una función que facilite la tarea. Detalle de los componentes principales para definir nuestra función: leer &lt;-: Es el nombre de la función y nombre que se utiliza para llamarla. function(img): Es una función que recibe un identificador de la imagen id de la lista imgs. f &lt;- 0.0001: Para convertir los DN a \\(\\rho\\) utilizamos el factor de escala presentado en el cuadro . Así el valor almacenado en cada ráster es la representación fiel de la energía recibida en cada píxel (ver ). variable &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[ID], silent = T)): Siguiendo el orden de capas del cuadro cargamos en una variable. Se agrega el parámetro silent = T que nos ahorra ver un mensaje en pantalla por cada lectura realizada. s &lt;- stack(r,g,b,nir,swir1,swir2,swir3,qa): Convertimos todas las capas en un modelo rasterStack. names(s) &lt;- c('r','g','b','nir','swir1','swir2','swir3','qa'): Asignamos nombres propios a cada capa para fácil referencia. s: Al ser la última línea, es el objeto que regresa la función. Y todo integrado: leer &lt;- function(img){ f &lt;- 0.0001 r &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[1], silent = T)) * f g &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[4], silent = T)) * f b &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[3], silent = T)) * f nir &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[2], silent = T)) * f swir1 &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[5], silent = T)) * f swir2 &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[6], silent = T)) * f swir3 &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[7], silent = T)) * f qa &lt;- raster(readGDAL(imgs[[img]]$SDS4gdal[12], silent = T)) s &lt;- stack(r, g, b, nir, swir1, swir2, swir3, qa) names(s) &lt;- c(&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;nir&quot;,&quot;swir1&quot;,&quot;swir2&quot;,&quot;swir3&quot;,&quot;qa&quot;) s } Y aplicamos nuestra función para leer los datos: imagen1 &lt;- leer(img = 1) imagen2 &lt;- leer(img = 2) imagen3 &lt;- leer(img = 3) imagen4 &lt;- leer(img = 4) 15.3.1 Mapeo RGB Hasta ahora hemos trabajado principalmente con objetos rasterLayer y para generar un mapa usamos el comando plot(), se define la paleta de colores, algunos otros parámetros y se genera la gráfica. Para los objetos rasterStack o rasterBrick existe la versión especializada plotRGB() que permite realizar un gráfico RGB basado en tres capas. Esas tres capas (que también podemos denominar bandas porque pueden representar diferentes anchos de banda en el espectro electromagnético) se combinan de manera que representan el canal rojo, verde y azul para formar imágenes en color. Figura 15.4: Descripción Gráfica del método stretch Lineal. Figura 15.5: Descripción Gráfica del método stretch Histograma r: Índice o nombre de la capa que se usará para definir el canal rojo de la imagen. g: Índice o nombre de la capa que se usará para definir el canal verde de la imagen. b: Índice o nombre de la capa que se usará para definir el canal azul de la imagen. stretch: Se encarga de realizar ajustes de visualización (no modifica los valores internos del objeto) para aprovechar toda la escala de tonos de color en la imagen. Los valores permitidos son lin: método lineal, donde el rango de ND (niveles digitales) se ajusta para ocupar todo el rango disponible (Figura 15.4). Por ejemplo, el rango \\(50 - 240\\) se extiende al rango \\(0 - 255\\) (ejemplo con 8 bit). El segundo, hist: método histograma, donde los valores además de extenderlos al rango completo de valores (\\(0 - 255\\) a 8 bit) proporcionalmente a su frecuencia, a mayor cantidad del valor digital, mayor rango de ND asignados (ver figura 15.5). La sintaxis básica para crear una imagen en color verdadero es asignar por cada canal el color correspondiente: plotRGB(imagen1, r=1, g=2, b=3, stretch=&quot;lin&quot;) O usar los nombres de capas para no tener que recordar el valor numérico de índice dentro del objeto Stack, por ejemplo: plotRGB(imagen1, r=&quot;r&quot;, g=&quot;g&quot;, b=&quot;b&quot;, stretch=&quot;lin&quot;) La figura 15.6 muestra el resultado de la gráfica en color verdadero, en el cañon r la banda 1 o r, en el cañon g la banda 2 o g y en el cañon b la banda 3 o b. Figura 15.6: Ploteo de las imágenes utilizadas en el ejercicio usando las bandas RGB. Guardamos en disco las imágenes descargadas y procesadas para el posterior uso en el tema de la combinación de bandas (ver ??). writeRaster(imagen1,here(&quot;raw&quot;,&quot;mosaico-test11.grd&quot;),overwrite=T) writeRaster(imagen2,here(&quot;raw&quot;,&quot;mosaico-test22.grd&quot;),overwrite=T) writeRaster(imagen3,here(&quot;raw&quot;,&quot;mosaico-test33.grd&quot;),overwrite=T) writeRaster(imagen4,here(&quot;raw&quot;,&quot;mosaico-test44.grd&quot;),overwrite=T) "]]
